<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Code Session Explorer</title>
    <style>{{ css|safe }}</style>
</head>
<body>
    <div class="status-bar" id="status-bar">
        <div class="status-indicator">
            <button class="hamburger-btn" id="hamburger-btn" title="Toggle sidebar">&#9776;</button>
            <span class="status-dot"></span>
            <span id="status-text">Connecting...</span>
        </div>
        <div class="session-title-bar" id="session-title-bar"></div>
    </div>

    <!-- Sidebar -->
    <div class="sidebar-overlay" id="sidebar-overlay"></div>
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <input type="text" id="sidebar-search" placeholder="Search sessions..." class="sidebar-search">
            <div class="sidebar-controls">
                <label class="auto-switch" id="auto-switch-label">
                    <input type="checkbox" id="auto-switch" checked>
                    <span>Auto-switch</span>
                </label>
                <button class="new-session-btn" id="new-session-btn" title="New session in custom directory">+ New</button>
            </div>
        </div>
        <div class="project-list" id="project-list"></div>
    </div>

    <!-- Main content -->
    <div class="main-content" id="main-content">
        <div class="container">
            <h1>Claude Code Session Explorer</h1>
            <div id="sessions"></div>
        </div>
    </div>

    <!-- Input bar -->
    <div class="input-bar hidden" id="input-bar">
        <div class="input-bar-left">
            <textarea
                id="message-input"
                class="input-textarea"
                placeholder="Send a message... (Shift+Enter for newline)"
                rows="1"
            ></textarea>
            <div class="input-status" id="input-status"></div>
        </div>
        <div class="input-bar-buttons">
            <button class="send-btn" id="send-btn">
                <span>Send</span>
            </button>
            <button class="interrupt-btn hidden" id="interrupt-btn">
                <span>Stop</span>
            </button>
        </div>
    </div>

    <!-- Session tooltip (hidden, shown on hover) -->
    <div class="session-tooltip" id="session-tooltip" style="display: none;"></div>

    <!-- Message tooltip for token usage (hidden, shown on hover) -->
    <div class="message-tooltip" id="message-tooltip"></div>

    <!-- Floating controls -->
    <div class="floating-controls" id="floating-controls">
        <button class="scroll-btn" id="scroll-top-btn" title="Scroll to top">&#8593;</button>
        <label class="auto-scroll-float" id="auto-scroll-float">
            <input type="checkbox" id="auto-scroll-checkbox" checked>
            <span>Auto</span>
        </label>
        <button class="scroll-btn" id="scroll-bottom-btn" title="Scroll to bottom">&#8595;</button>
    </div>

    <script>
    (function() {
        // DOM elements
        const sessionsContainer = document.getElementById('sessions');
        const projectListContainer = document.getElementById('project-list');
        const statusBar = document.getElementById('status-bar');
        const statusText = document.getElementById('status-text');
        const sessionTitleBar = document.getElementById('session-title-bar');
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const hamburgerBtn = document.getElementById('hamburger-btn');
        const autoSwitchCheckbox = document.getElementById('auto-switch');
        const autoSwitchLabel = document.getElementById('auto-switch-label');
        const searchInput = document.getElementById('sidebar-search');
        const inputBar = document.getElementById('input-bar');
        const mainContent = document.getElementById('main-content');
        const messageInput = document.getElementById('message-input');
        const inputStatus = document.getElementById('input-status');
        const sendBtn = document.getElementById('send-btn');
        const interruptBtn = document.getElementById('interrupt-btn');
        const newSessionBtn = document.getElementById('new-session-btn');
        const sessionTooltip = document.getElementById('session-tooltip');
        const messageTooltip = document.getElementById('message-tooltip');
        const scrollTopBtn = document.getElementById('scroll-top-btn');
        const scrollBottomBtn = document.getElementById('scroll-bottom-btn');
        const autoScrollCheckbox = document.getElementById('auto-scroll-checkbox');
        const autoScrollFloat = document.getElementById('auto-scroll-float');

        let eventSource = null;
        const MAX_MESSAGES = 500;
        const MAX_TITLE_LENGTH = 50;

        // State
        const sessions = new Map();  // session_id -> session object
        const projects = new Map();  // project_name -> { name, sessions: Set, lastActivity, element }
        let activeSessionId = null;
        let sidebarOpen = localStorage.getItem('sidebarOpen') !== 'false';  // default open
        let autoSwitch = localStorage.getItem('autoSwitch') !== 'false';    // default on
        let autoScroll = localStorage.getItem('autoScroll') !== 'false';    // default on
        let autoSwitchDebounce = null;
        let catchupComplete = false;
        let sendEnabled = false;
        const sessionStatus = new Map();
        let pendingSessionCounter = 0;
        const pendingMessages = [];
        let tooltipTimeout = null;

        // Check if mobile
        function isMobile() {
            return window.innerWidth <= 768;
        }

        // Sidebar toggle
        function updateSidebarState() {
            if (sidebarOpen) {
                sidebar.classList.remove('closed');
                mainContent.classList.remove('sidebar-closed');
                inputBar.classList.remove('sidebar-closed');
                if (isMobile()) {
                    sidebarOverlay.classList.add('visible');
                }
            } else {
                sidebar.classList.add('closed');
                mainContent.classList.add('sidebar-closed');
                inputBar.classList.add('sidebar-closed');
                sidebarOverlay.classList.remove('visible');
            }
            localStorage.setItem('sidebarOpen', sidebarOpen);
        }

        function toggleSidebar() {
            sidebarOpen = !sidebarOpen;
            updateSidebarState();
        }

        hamburgerBtn.addEventListener('click', toggleSidebar);
        sidebarOverlay.addEventListener('click', function() {
            sidebarOpen = false;
            updateSidebarState();
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            if (!isMobile()) {
                sidebarOverlay.classList.remove('visible');
            } else if (sidebarOpen) {
                sidebarOverlay.classList.add('visible');
            }
        });

        // Initialize sidebar state
        updateSidebarState();

        // Auto-switch UI
        function updateAutoSwitchUI() {
            autoSwitch = autoSwitchCheckbox.checked;
            if (autoSwitch) {
                autoSwitchLabel.classList.add('active');
            } else {
                autoSwitchLabel.classList.remove('active');
            }
            localStorage.setItem('autoSwitch', autoSwitch);
        }
        autoSwitchCheckbox.checked = autoSwitch;
        autoSwitchCheckbox.addEventListener('change', updateAutoSwitchUI);
        updateAutoSwitchUI();

        // Auto-scroll UI (floating controls)
        function updateAutoScrollUI() {
            autoScroll = autoScrollCheckbox.checked;
            if (autoScroll) {
                autoScrollFloat.classList.add('active');
            } else {
                autoScrollFloat.classList.remove('active');
            }
            localStorage.setItem('autoScroll', autoScroll);
        }
        autoScrollCheckbox.checked = autoScroll;
        autoScrollCheckbox.addEventListener('change', updateAutoScrollUI);
        updateAutoScrollUI();

        // Scroll buttons
        scrollTopBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        scrollBottomBtn.addEventListener('click', function() {
            window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
        });

        // Search functionality
        function filterSidebar(query) {
            const lowerQuery = query.toLowerCase().trim();

            projects.forEach(function(project) {
                let projectHasMatch = false;

                project.sessions.forEach(function(sessionId) {
                    const session = sessions.get(sessionId);
                    if (!session) return;

                    if (!lowerQuery) {
                        session.sidebarItem.style.display = '';
                        projectHasMatch = true;
                        return;
                    }

                    const titleMatch = (session.displayTitle || '').toLowerCase().includes(lowerQuery);
                    const projectMatch = project.name.toLowerCase().includes(lowerQuery);
                    const contentMatch = session.container.textContent.toLowerCase().includes(lowerQuery);

                    if (titleMatch || projectMatch || contentMatch) {
                        session.sidebarItem.style.display = '';
                        projectHasMatch = true;
                    } else {
                        session.sidebarItem.style.display = 'none';
                    }
                });

                if (project.element) {
                    project.element.style.display = projectHasMatch ? '' : 'none';
                }
            });
        }

        searchInput.addEventListener('input', function() {
            filterSidebar(this.value);
        });

        // Send functionality
        async function checkSendEnabled() {
            try {
                const response = await fetch('/send-enabled');
                const data = await response.json();
                sendEnabled = data.enabled;
                if (sendEnabled) {
                    inputBar.classList.remove('hidden');
                } else {
                    inputBar.classList.add('hidden');
                }
            } catch (e) {
                console.error('Failed to check send-enabled:', e);
                sendEnabled = false;
            }
        }

        function updateInputBarUI() {
            if (!activeSessionId) {
                sendBtn.disabled = true;
                inputStatus.textContent = '';
                inputStatus.className = 'input-status';
                sendBtn.classList.remove('hidden');
                interruptBtn.classList.add('hidden');
                return;
            }

            const session = sessions.get(activeSessionId);
            const status = sessionStatus.get(activeSessionId) || { running: false, queued_messages: 0 };

            if (session && session.pending && session.starting) {
                inputStatus.innerHTML = '<span class="spinner"></span> Starting session...';
                inputStatus.className = 'input-status running';
                sendBtn.classList.remove('hidden');
                sendBtn.disabled = true;
                interruptBtn.classList.add('hidden');
                return;
            }

            if (status.running) {
                inputStatus.className = 'input-status running';
                sendBtn.classList.add('hidden');
                interruptBtn.classList.remove('hidden');

                if (status.queued_messages > 0) {
                    inputStatus.innerHTML = '<span class="spinner"></span> ' +
                        status.queued_messages + ' message' + (status.queued_messages > 1 ? 's' : '') + ' queued...';
                } else {
                    inputStatus.innerHTML = '<span class="spinner"></span> Claude is thinking...';
                }
            } else {
                inputStatus.textContent = '';
                inputStatus.className = 'input-status';
                sendBtn.classList.remove('hidden');
                interruptBtn.classList.add('hidden');
            }

            sendBtn.disabled = !messageInput.value.trim();
        }

        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message || !activeSessionId) return;

            const session = sessions.get(activeSessionId);
            if (!session) return;

            sendBtn.disabled = true;

            if (session.pending) {
                await startPendingSession(session, message);
                return;
            }

            const placeholder = createPlaceholderMessage(activeSessionId, message);
            messageInput.value = '';
            autoResizeTextarea();

            try {
                const response = await fetch('/sessions/' + activeSessionId + '/send', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: message })
                });

                if (!response.ok) {
                    const data = await response.json();
                    alert('Error: ' + (data.detail || 'Failed to send message'));
                    if (placeholder) {
                        placeholder.element.remove();
                        const idx = pendingMessages.indexOf(placeholder);
                        if (idx > -1) pendingMessages.splice(idx, 1);
                    }
                }
            } catch (e) {
                alert('Error: Failed to send message');
                console.error('Send error:', e);
                if (placeholder) {
                    placeholder.element.remove();
                    const idx = pendingMessages.indexOf(placeholder);
                    if (idx > -1) pendingMessages.splice(idx, 1);
                }
            }

            updateInputBarUI();
        }

        async function startPendingSession(pendingSession, message) {
            inputStatus.innerHTML = '<span class="spinner"></span> Starting session...';
            inputStatus.className = 'input-status running';

            try {
                const response = await fetch('/sessions/new', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: message,
                        cwd: pendingSession.cwd || null
                    })
                });

                if (response.ok) {
                    messageInput.value = '';
                    autoResizeTextarea();
                    pendingSession.starting = true;
                    pendingSession.startedAt = Date.now();
                } else {
                    const data = await response.json();
                    alert('Error: ' + (data.detail || 'Failed to start session'));
                    inputStatus.textContent = '';
                    inputStatus.className = 'input-status';
                }
            } catch (e) {
                alert('Error: Failed to start session');
                console.error('New session error:', e);
                inputStatus.textContent = '';
                inputStatus.className = 'input-status';
            }

            updateInputBarUI();
        }

        async function interruptSession() {
            if (!activeSessionId) return;

            try {
                const response = await fetch('/sessions/' + activeSessionId + '/interrupt', {
                    method: 'POST'
                });

                if (!response.ok) {
                    const data = await response.json();
                    console.error('Interrupt failed:', data.detail);
                }
            } catch (e) {
                console.error('Interrupt error:', e);
            }
        }

        function autoResizeTextarea() {
            messageInput.style.height = 'auto';
            messageInput.style.height = Math.min(messageInput.scrollHeight, 120) + 'px';
        }

        messageInput.addEventListener('input', function() {
            autoResizeTextarea();
            updateInputBarUI();
        });

        messageInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (!sendBtn.disabled && !sendBtn.classList.contains('hidden')) {
                    sendMessage();
                }
            }
        });

        sendBtn.addEventListener('click', sendMessage);
        interruptBtn.addEventListener('click', interruptSession);

        // New session functionality
        function createPendingSession(cwd, projectName) {
            pendingSessionCounter++;
            const pendingId = 'pending-' + pendingSessionCounter;

            // Use provided cwd/projectName, or fall back to active session's project
            if (!cwd && activeSessionId) {
                const activeSession = sessions.get(activeSessionId);
                if (activeSession && activeSession.cwd) {
                    cwd = activeSession.cwd;
                    projectName = projectName || activeSession.projectName;
                }
            }

            const displayProjectName = projectName || 'New Session';
            const session = createSession(pendingId, 'New Session', displayProjectName, null, null, null, cwd, null);
            session.pending = true;
            session.cwd = cwd;

            session.sidebarItem.classList.add('pending');
            session.container.innerHTML = '<div class="pending-session-placeholder">' +
                '<p>Type a message below to start this Claude session' +
                (cwd ? ' in <strong>' + escapeHtml(displayProjectName) + '</strong>' : '') +
                '</p></div>';

            switchToSession(pendingId);
            messageInput.focus();

            // Close sidebar on mobile after selecting
            if (isMobile()) {
                sidebarOpen = false;
                updateSidebarState();
            }
        }

        function promptForNewSession() {
            // Get a default directory from active session if available
            let defaultDir = '';
            if (activeSessionId) {
                const activeSession = sessions.get(activeSessionId);
                if (activeSession && activeSession.cwd) {
                    defaultDir = activeSession.cwd;
                }
            }

            const dir = prompt('Enter working directory for new session:', defaultDir);
            if (dir === null) return; // Cancelled

            const trimmedDir = dir.trim();
            if (!trimmedDir) {
                alert('Please enter a directory path');
                return;
            }

            // Extract project name from path (last component)
            const projectName = trimmedDir.split('/').filter(s => s).pop() || 'New Session';

            createPendingSession(trimmedDir, projectName);
        }

        newSessionBtn.addEventListener('click', promptForNewSession);

        function updateStatus(status, text) {
            statusBar.className = 'status-bar ' + status;
            statusText.textContent = text;
        }

        function isNearBottom() {
            const threshold = 150;
            return (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - threshold);
        }

        function processNewElement(element) {
            element.querySelectorAll('time[data-timestamp]').forEach(function(el) {
                const timestamp = el.getAttribute('data-timestamp');
                const date = new Date(timestamp);
                const now = new Date();
                const isToday = date.toDateString() === now.toDateString();
                const timeStr = date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
                if (isToday) { el.textContent = timeStr; }
                else { el.textContent = date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) + ' ' + timeStr; }
            });

            element.querySelectorAll('pre.json').forEach(function(el) {
                let text = el.textContent;
                text = text.replace(/"([^"]+)":/g, '<span style="color: #ce93d8">"$1"</span>:');
                text = text.replace(/: "([^"]*)"/g, ': <span style="color: #81d4fa">"$1"</span>');
                text = text.replace(/: (\d+)/g, ': <span style="color: #ffcc80">$1</span>');
                text = text.replace(/: (true|false|null)/g, ': <span style="color: #f48fb1">$1</span>');
                el.innerHTML = text;
            });

            element.querySelectorAll('.truncatable').forEach(function(wrapper) {
                const content = wrapper.querySelector('.truncatable-content');
                const btn = wrapper.querySelector('.expand-btn');
                if (content && btn && content.scrollHeight > 250) {
                    wrapper.classList.add('truncated');
                    btn.addEventListener('click', function() {
                        if (wrapper.classList.contains('truncated')) {
                            wrapper.classList.remove('truncated');
                            wrapper.classList.add('expanded');
                            btn.textContent = 'Show less';
                        } else {
                            wrapper.classList.remove('expanded');
                            wrapper.classList.add('truncated');
                            btn.textContent = 'Show more';
                        }
                    });
                }
            });

            // Add tooltip handlers for assistant messages with usage data
            // Check both the element itself and its descendants
            const assistantMessages = [];
            if (element.matches && element.matches('.message.assistant[data-usage-input]')) {
                assistantMessages.push(element);
            }
            element.querySelectorAll('.message.assistant[data-usage-input]').forEach(function(msg) {
                assistantMessages.push(msg);
            });
            assistantMessages.forEach(function(msg) {
                const header = msg.querySelector('.message-header');
                if (header) {
                    header.addEventListener('mouseenter', function(e) {
                        showMessageTooltip(msg, e);
                    });
                    header.addEventListener('mouseleave', hideMessageTooltip);
                    header.addEventListener('mousemove', function(e) {
                        positionMessageTooltip(e);
                    });
                }
            });
        }

        let messageTooltipTimeout = null;

        function showMessageTooltip(msgEl, e) {
            if (messageTooltipTimeout) clearTimeout(messageTooltipTimeout);

            messageTooltipTimeout = setTimeout(function() {
                const input = parseInt(msgEl.dataset.usageInput) || 0;
                const output = parseInt(msgEl.dataset.usageOutput) || 0;
                const cacheCreate = parseInt(msgEl.dataset.usageCacheCreate) || 0;
                const cacheRead = parseInt(msgEl.dataset.usageCacheRead) || 0;

                messageTooltip.innerHTML = `
                    <div class="usage-row">
                        <span class="usage-item"><span class="usage-label">In:</span>${formatTokenCount(input)}</span>
                        <span class="usage-item"><span class="usage-label">Out:</span>${formatTokenCount(output)}</span>
                        <span class="usage-item"><span class="usage-label">Cache↑:</span>${formatTokenCount(cacheCreate)}</span>
                        <span class="usage-item"><span class="usage-label">Cache↓:</span>${formatTokenCount(cacheRead)}</span>
                    </div>
                `;
                // Position first with visibility hidden to measure, then show
                messageTooltip.style.visibility = 'hidden';
                messageTooltip.style.display = 'block';
                positionMessageTooltip(e);
                messageTooltip.style.visibility = 'visible';
            }, 200);
        }

        function positionMessageTooltip(e) {
            const padding = 10;
            let left = e.clientX + padding;
            let top = e.clientY + padding;

            // Get dimensions after rendering
            const rect = messageTooltip.getBoundingClientRect();
            if (rect.width > 0 && left + rect.width > window.innerWidth) {
                left = e.clientX - rect.width - padding;
            }
            if (rect.height > 0 && top + rect.height > window.innerHeight) {
                top = e.clientY - rect.height - padding;
            }

            messageTooltip.style.left = left + 'px';
            messageTooltip.style.top = top + 'px';
        }

        function hideMessageTooltip() {
            if (messageTooltipTimeout) {
                clearTimeout(messageTooltipTimeout);
                messageTooltipTimeout = null;
            }
            messageTooltip.style.display = 'none';
        }

        function formatTimestamp(ts) {
            if (!ts) return 'Unknown';
            const date = typeof ts === 'number' ? new Date(ts * 1000) : new Date(ts);
            if (isNaN(date.getTime())) return 'Unknown';
            const now = new Date();
            const isToday = date.toDateString() === now.toDateString();
            const timeStr = date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
            if (isToday) {
                return 'Today ' + timeStr;
            }
            return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) + ' ' + timeStr;
        }

        function truncateTitle(text, maxLength) {
            if (!text) return 'Untitled';
            // Remove newlines and excess whitespace
            text = text.replace(/\s+/g, ' ').trim();
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        }

        function getOrCreateProject(projectName, projectPath) {
            if (projects.has(projectName)) {
                const project = projects.get(projectName);
                // Update path if we have a better one
                if (projectPath && !project.path) {
                    project.path = projectPath;
                }
                return project;
            }

            const projectItem = document.createElement('div');
            projectItem.className = 'project-item';
            projectItem.innerHTML = `
                <div class="project-header">
                    <span class="project-icon">&#9660;</span>
                    <span class="unread-dot"></span>
                    <span class="project-name">${escapeHtml(projectName)}</span>
                    <button class="project-new-btn" title="New session in ${escapeHtml(projectName)}">+</button>
                </div>
                <div class="session-list"></div>
            `;

            const projectHeader = projectItem.querySelector('.project-header');
            const projectNewBtn = projectItem.querySelector('.project-new-btn');

            projectHeader.addEventListener('click', function(e) {
                // Don't toggle when clicking the new button
                if (e.target === projectNewBtn) return;
                projectItem.classList.toggle('collapsed');
            });

            projectNewBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                createPendingSession(projectPath || null, projectName);
            });

            projectListContainer.appendChild(projectItem);

            const project = {
                name: projectName,
                path: projectPath || null,
                sessions: new Set(),
                lastActivity: 0,
                element: projectItem,
                sessionListElement: projectItem.querySelector('.session-list')
            };
            projects.set(projectName, project);

            return project;
        }

        function createSession(sessionId, name, projectName, firstMessage, startedAt, lastUpdatedAt, projectPath, tokenUsage) {
            if (sessions.has(sessionId)) return sessions.get(sessionId);

            // Create container with session header
            const container = document.createElement('div');
            container.className = 'session-container';
            container.dataset.session = sessionId;

            const displayTitle = truncateTitle(firstMessage || name, MAX_TITLE_LENGTH);

            // Add session header (title only - auto-scroll is in floating controls)
            const sessionHeader = document.createElement('div');
            sessionHeader.className = 'session-header';
            sessionHeader.innerHTML = `<span class="session-title-display">${escapeHtml(displayTitle)}</span>`;
            container.appendChild(sessionHeader);

            sessionsContainer.appendChild(container);

            // Create sidebar item
            const sidebarItem = document.createElement('div');
            sidebarItem.className = 'session-item';
            sidebarItem.dataset.session = sessionId;
            sidebarItem.innerHTML = `
                <span class="unread-dot"></span>
                <span class="session-title">${escapeHtml(displayTitle)}</span>
                <span class="close-btn" title="Close">&times;</span>
            `;

            sidebarItem.addEventListener('click', function(e) {
                if (e.target.classList.contains('close-btn')) {
                    removeSession(sessionId);
                } else {
                    switchToSession(sessionId, true);  // Scroll to bottom when opening
                    // Close sidebar on mobile
                    if (isMobile()) {
                        sidebarOpen = false;
                        updateSidebarState();
                    }
                }
            });

            // Tooltip handlers
            sidebarItem.addEventListener('mouseenter', function(e) {
                showTooltip(sessionId, e);
            });
            sidebarItem.addEventListener('mouseleave', hideTooltip);
            sidebarItem.addEventListener('mousemove', function(e) {
                positionTooltip(e);
            });

            // Add to project
            const project = getOrCreateProject(projectName || 'Unknown', projectPath);
            project.sessions.add(sessionId);
            project.sessionListElement.appendChild(sidebarItem);

            const session = {
                id: sessionId,
                name: name,
                projectName: projectName || 'Unknown',
                displayTitle: displayTitle,
                firstMessage: firstMessage,
                container: container,
                sidebarItem: sidebarItem,
                messageCount: 0,
                lastActivity: lastUpdatedAt ? lastUpdatedAt * 1000 : Date.now(),
                startedAt: startedAt || null,
                lastUpdatedAt: lastUpdatedAt || null,
                cwd: projectPath || null,
                tokenUsage: tokenUsage || null
            };
            sessions.set(sessionId, session);

            // Update project's last activity
            project.lastActivity = Math.max(project.lastActivity, session.lastActivity);

            // If this is the first session, activate it
            if (sessions.size === 1) {
                switchToSession(sessionId);
            }

            return session;
        }

        function formatTokenCount(count) {
            if (!count || count === 0) return '0';
            if (count >= 1000000) {
                return (count / 1000000).toFixed(1) + 'M';
            } else if (count >= 1000) {
                return (count / 1000).toFixed(1) + 'K';
            }
            return count.toString();
        }

        function showTooltip(sessionId, e) {
            const session = sessions.get(sessionId);
            if (!session) return;

            if (tooltipTimeout) clearTimeout(tooltipTimeout);

            tooltipTimeout = setTimeout(function() {
                const started = formatTimestamp(session.startedAt);
                const updated = formatTimestamp(session.lastUpdatedAt);
                const fullMessage = session.firstMessage || 'No message';

                let usageHtml = '';
                if (session.tokenUsage && session.tokenUsage.message_count > 0) {
                    const u = session.tokenUsage;
                    usageHtml = `
                        <div class="tooltip-label">Token Usage</div>
                        <div class="tooltip-value tooltip-usage">
                            <span class="usage-item">In: ${formatTokenCount(u.input_tokens)}</span>
                            <span class="usage-item">Out: ${formatTokenCount(u.output_tokens)}</span>
                            <span class="usage-item">Cache↑: ${formatTokenCount(u.cache_creation_tokens)}</span>
                            <span class="usage-item">Cache↓: ${formatTokenCount(u.cache_read_tokens)}</span>
                        </div>
                    `;
                }

                sessionTooltip.innerHTML = `
                    <div class="tooltip-label">Created</div>
                    <div class="tooltip-value">${escapeHtml(started)}</div>
                    <div class="tooltip-label">Last updated</div>
                    <div class="tooltip-value">${escapeHtml(updated)}</div>
                    ${usageHtml}
                    <div class="tooltip-label">First message</div>
                    <div class="tooltip-value tooltip-message">${escapeHtml(fullMessage)}</div>
                `;
                sessionTooltip.style.display = 'block';
                positionTooltip(e);
            }, 300);
        }

        function positionTooltip(e) {
            const tooltip = sessionTooltip;
            const padding = 10;

            let left = e.clientX + padding;
            let top = e.clientY + padding;

            // Adjust if tooltip goes off-screen
            const rect = tooltip.getBoundingClientRect();
            if (left + rect.width > window.innerWidth) {
                left = e.clientX - rect.width - padding;
            }
            if (top + rect.height > window.innerHeight) {
                top = e.clientY - rect.height - padding;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        function hideTooltip() {
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
                tooltipTimeout = null;
            }
            sessionTooltip.style.display = 'none';
        }

        function removeSession(sessionId) {
            const session = sessions.get(sessionId);
            if (!session) return;

            // Remove from project
            const project = projects.get(session.projectName);
            if (project) {
                project.sessions.delete(sessionId);
                // Remove project if empty
                if (project.sessions.size === 0) {
                    project.element.remove();
                    projects.delete(session.projectName);
                }
            }

            session.container.remove();
            session.sidebarItem.remove();
            sessions.delete(sessionId);

            if (activeSessionId === sessionId) {
                const firstSession = sessions.keys().next().value;
                if (firstSession) {
                    switchToSession(firstSession);
                } else {
                    activeSessionId = null;
                }
            }
        }

        function reorderSidebar() {
            // FLIP animation: capture positions before reorder
            const projectPositions = new Map();
            const sessionPositions = new Map();

            projects.forEach(function(project) {
                projectPositions.set(project.name, project.element.getBoundingClientRect());
            });
            sessions.forEach(function(session) {
                sessionPositions.set(session.id, session.sidebarItem.getBoundingClientRect());
            });

            // Sort projects by lastActivity
            const sortedProjects = Array.from(projects.values()).sort((a, b) => b.lastActivity - a.lastActivity);

            sortedProjects.forEach(function(project) {
                projectListContainer.appendChild(project.element);

                // Sort sessions within project
                const sortedSessions = Array.from(project.sessions)
                    .map(id => sessions.get(id))
                    .filter(s => s)
                    .sort((a, b) => b.lastActivity - a.lastActivity);

                sortedSessions.forEach(function(session) {
                    project.sessionListElement.appendChild(session.sidebarItem);
                });
            });

            // FLIP animation: animate from old to new positions
            projects.forEach(function(project) {
                const oldRect = projectPositions.get(project.name);
                const newRect = project.element.getBoundingClientRect();
                if (oldRect && Math.abs(oldRect.top - newRect.top) > 1) {
                    const deltaY = oldRect.top - newRect.top;
                    project.element.style.transform = `translateY(${deltaY}px)`;
                    project.element.style.transition = 'none';
                    requestAnimationFrame(function() {
                        project.element.style.transition = 'transform 0.2s ease-out';
                        project.element.style.transform = '';
                    });
                }
            });

            sessions.forEach(function(session) {
                const oldRect = sessionPositions.get(session.id);
                const newRect = session.sidebarItem.getBoundingClientRect();
                if (oldRect && Math.abs(oldRect.top - newRect.top) > 1) {
                    const deltaY = oldRect.top - newRect.top;
                    session.sidebarItem.style.transform = `translateY(${deltaY}px)`;
                    session.sidebarItem.style.transition = 'none';
                    requestAnimationFrame(function() {
                        session.sidebarItem.style.transition = 'transform 0.2s ease-out';
                        session.sidebarItem.style.transform = '';
                    });
                }
            });
        }

        function switchToSession(sessionId, scrollToBottom = false) {
            const session = sessions.get(sessionId);
            if (!session) return;

            // Update containers
            sessions.forEach(function(s) {
                s.container.classList.remove('active');
                s.sidebarItem.classList.remove('active');
            });
            session.container.classList.add('active');
            session.sidebarItem.classList.add('active');
            activeSessionId = sessionId;

            // Clear unread/waiting state
            session.sidebarItem.classList.remove('unread', 'waiting');
            updateProjectUnreadState(session.projectName);

            // Update header title
            sessionTitleBar.textContent = session.displayTitle || session.name;

            updateInputBarUI();

            if (scrollToBottom) {
                requestAnimationFrame(function() {
                    window.scrollTo(0, document.body.scrollHeight);
                });
            }
        }

        function updateSessionWaitingState(sessionId) {
            const session = sessions.get(sessionId);
            if (!session) return;

            const status = sessionStatus.get(sessionId);
            const isWaiting = status && status.waiting_for_input;
            const hasUnread = session.sidebarItem.classList.contains('unread') ||
                              session.sidebarItem.classList.contains('waiting');

            // Update session item: waiting takes precedence over unread
            if (hasUnread && isWaiting) {
                session.sidebarItem.classList.remove('unread');
                session.sidebarItem.classList.add('waiting');
            } else if (hasUnread && !isWaiting) {
                session.sidebarItem.classList.remove('waiting');
                session.sidebarItem.classList.add('unread');
            }

            // Update project state
            updateProjectUnreadState(session.projectName);
        }

        function updateProjectUnreadState(projectName) {
            const project = projects.get(projectName);
            if (!project) return;

            // Check if any session in this project has unread/waiting messages
            let hasUnread = false;
            let hasWaiting = false;
            project.sessions.forEach(function(sessionId) {
                const session = sessions.get(sessionId);
                if (session) {
                    if (session.sidebarItem.classList.contains('waiting')) {
                        hasWaiting = true;
                    } else if (session.sidebarItem.classList.contains('unread')) {
                        hasUnread = true;
                    }
                }
            });

            // waiting takes precedence over unread for projects
            project.element.classList.remove('unread', 'waiting');
            if (hasWaiting) {
                project.element.classList.add('waiting');
            } else if (hasUnread) {
                project.element.classList.add('unread');
            }
        }

        function appendMessage(sessionId, html) {
            const session = sessions.get(sessionId);
            if (!session) return;

            const wasNearBottom = isNearBottom();
            const isActiveSession = sessionId === activeSessionId;

            const temp = document.createElement('div');
            temp.innerHTML = html;
            const msg = temp.firstElementChild;

            if (msg) {
                removePlaceholderIfMatches(sessionId, msg);

                session.container.appendChild(msg);
                processNewElement(msg);
                session.messageCount++;

                if (catchupComplete) {
                    session.lastActivity = Date.now();
                    session.lastUpdatedAt = Date.now() / 1000;

                    // Update project's last activity
                    const project = projects.get(session.projectName);
                    if (project) {
                        project.lastActivity = Math.max(project.lastActivity, session.lastActivity);
                    }

                    // Mark as unread/waiting if not the active session
                    if (!isActiveSession) {
                        const status = sessionStatus.get(sessionId);
                        if (status && status.waiting_for_input) {
                            session.sidebarItem.classList.add('waiting');
                        } else {
                            session.sidebarItem.classList.add('unread');
                        }
                        updateProjectUnreadState(session.projectName);
                    }

                    reorderSidebar();
                }

                while (session.container.children.length > MAX_MESSAGES + 1) {  // +1 for header
                    session.container.removeChild(session.container.children[1]);  // Skip header
                }

                // Handle auto-switch (only after initial catchup)
                if (catchupComplete && autoSwitch && !isActiveSession) {
                    if (autoSwitchDebounce) clearTimeout(autoSwitchDebounce);
                    autoSwitchDebounce = setTimeout(function() {
                        switchToSession(sessionId, true);
                    }, 100);
                }

                // Auto-scroll within session
                if (isActiveSession && (autoScroll || wasNearBottom)) {
                    msg.scrollIntoView({ behavior: 'smooth', block: 'end' });
                }
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function createPlaceholderMessage(sessionId, messageText) {
            const session = sessions.get(sessionId);
            if (!session) return null;

            const timestamp = new Date().toISOString();
            const msgId = 'placeholder-' + Date.now();

            const html = '<div class="message user placeholder-message" id="' + msgId + '">' +
                '<div class="message-header">' +
                '<span class="role-label">User</span>' +
                '<time datetime="' + timestamp + '">Sending...</time>' +
                '</div>' +
                '<div class="message-content">' +
                '<div class="user-content"><p>' + escapeHtml(messageText) + '</p></div>' +
                '</div>' +
                '</div>';

            const temp = document.createElement('div');
            temp.innerHTML = html;
            const element = temp.firstElementChild;

            session.container.appendChild(element);

            const placeholder = { sessionId: sessionId, messageText: messageText, element: element };
            pendingMessages.push(placeholder);

            element.scrollIntoView({ behavior: 'smooth', block: 'end' });

            return placeholder;
        }

        function removePlaceholderIfMatches(sessionId, messageElement) {
            const incomingContent = messageElement.querySelector('.user-content');
            if (!incomingContent) return;

            const incomingText = incomingContent.textContent.trim();

            for (let i = 0; i < pendingMessages.length; i++) {
                const pending = pendingMessages[i];
                if (pending.sessionId === sessionId && pending.messageText.trim() === incomingText) {
                    pending.element.remove();
                    pendingMessages.splice(i, 1);
                    return true;
                }
            }
            return false;
        }

        function connect() {
            updateStatus('reconnecting', 'Connecting...');
            catchupComplete = false;

            checkSendEnabled();

            eventSource = new EventSource('/events');

            eventSource.addEventListener('sessions', function(e) {
                const data = JSON.parse(e.data);
                data.sessions.forEach(function(session) {
                    createSession(
                        session.id,
                        session.name,
                        session.projectName,
                        session.firstMessage,
                        session.startedAt,
                        session.lastUpdatedAt,
                        session.projectPath,
                        session.tokenUsage
                    );
                });
                reorderSidebar();
                updateStatus('', 'Connected');
            });

            eventSource.addEventListener('catchup_complete', function(e) {
                catchupComplete = true;
                if (activeSessionId) {
                    window.scrollTo(0, document.body.scrollHeight);
                }
            });

            eventSource.addEventListener('session_added', function(e) {
                const data = JSON.parse(e.data);

                let mergedPendingId = null;
                const MERGE_WINDOW_MS = 30000;
                sessions.forEach(function(session, sessionId) {
                    if (session.pending && session.starting &&
                        (Date.now() - session.startedAt) < MERGE_WINDOW_MS) {
                        mergedPendingId = sessionId;
                    }
                });

                if (mergedPendingId) {
                    const pendingSession = sessions.get(mergedPendingId);
                    const wasPendingActive = (activeSessionId === mergedPendingId);

                    removeSession(mergedPendingId);

                    const session = createSession(
                        data.id,
                        data.name,
                        data.projectName,
                        data.firstMessage,
                        data.startedAt,
                        data.lastUpdatedAt,
                        data.projectPath,
                        data.tokenUsage
                    );

                    if (wasPendingActive && session) {
                        switchToSession(data.id, true);
                    }
                } else {
                    const session = createSession(
                        data.id,
                        data.name,
                        data.projectName,
                        data.firstMessage,
                        data.startedAt,
                        data.lastUpdatedAt,
                        data.projectPath,
                        data.tokenUsage
                    );
                    if (autoSwitch && session) {
                        switchToSession(data.id, true);
                    }
                }
            });

            eventSource.addEventListener('session_removed', function(e) {
                const data = JSON.parse(e.data);
                removeSession(data.id);
            });

            eventSource.addEventListener('message', function(e) {
                const data = JSON.parse(e.data);
                if (data.type === 'html' && data.session_id) {
                    if (!sessions.has(data.session_id)) {
                        createSession(data.session_id, data.session_id.substring(0, 8), 'Unknown', null, null, null, null, null);
                    }
                    appendMessage(data.session_id, data.content);
                }
            });

            eventSource.addEventListener('ping', function(e) {
                // Keep-alive
            });

            eventSource.addEventListener('session_status', function(e) {
                const data = JSON.parse(e.data);
                sessionStatus.set(data.session_id, {
                    running: data.running,
                    queued_messages: data.queued_messages,
                    waiting_for_input: data.waiting_for_input
                });
                if (data.session_id === activeSessionId) {
                    updateInputBarUI();
                }
                // Update waiting state on sidebar
                updateSessionWaitingState(data.session_id);
            });

            eventSource.addEventListener('reinitialize', function(e) {
                console.warn('Server requested reinitialize:', JSON.parse(e.data));
                eventSource.close();
                setTimeout(connect, 1000);
            });

            eventSource.onopen = function() {
                updateStatus('', 'Connected');
            };

            eventSource.onerror = function(e) {
                if (eventSource.readyState === EventSource.CLOSED) {
                    updateStatus('disconnected', 'Disconnected');
                } else {
                    updateStatus('reconnecting', 'Reconnecting...');
                }
            };
        }

        connect();

        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'visible' && eventSource.readyState === EventSource.CLOSED) {
                connect();
            }
        });
    })();
    </script>
</body>
</html>
