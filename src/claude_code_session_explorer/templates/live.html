<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Code Session Explorer</title>
    <style>{{ css|safe }}</style>
</head>
<body>
    <div class="status-bar" id="status-bar">
        <div class="status-indicator">
            <button class="hamburger-btn" id="hamburger-btn" title="Toggle sidebar">&#9776;</button>
            <span class="status-dot"></span>
            <span id="status-text">Connecting...</span>
        </div>
        <div class="session-title-bar" id="session-title-bar"></div>
    </div>

    <!-- Sidebar -->
    <div class="sidebar-overlay" id="sidebar-overlay"></div>
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <input type="text" id="sidebar-search" placeholder="Search sessions..." class="sidebar-search">
            <div class="sidebar-controls">
                <label class="auto-switch" id="auto-switch-label">
                    <input type="checkbox" id="auto-switch" checked>
                    <span>Auto-switch</span>
                </label>
                <select class="sort-select" id="sort-select" title="Sort sessions by">
                    <option value="modified">Modified</option>
                    <option value="created">Created</option>
                </select>
                <button class="new-session-btn" id="new-session-btn" title="New session in custom directory">+ New</button>
            </div>
        </div>
        <div class="project-list" id="project-list"></div>
    </div>

    <!-- Main content -->
    <div class="main-content" id="main-content">
        <div class="container">
            <div class="project-header-bar">
                <h1 id="project-title">Claude Code Session Explorer</h1>
                <button class="copy-icon-btn" id="copy-path-btn" title="Copy project path" style="display: none;"></button>
            </div>
            <div class="session-id-bar" id="session-id-bar" style="display: none;">
                <span class="session-id-label">Session:</span>
                <code class="session-id-value" id="session-id-value"></code>
                <button class="copy-icon-btn copy-icon-btn-small" id="copy-session-btn" title="Copy session ID"></button>
            </div>
            <div id="sessions"></div>
        </div>
    </div>

    <!-- Input bar -->
    <div class="input-bar hidden" id="input-bar">
        <div class="input-bar-left">
            <textarea
                id="message-input"
                class="input-textarea"
                placeholder="Send a message... (Shift+Enter for newline)"
                rows="1"
            ></textarea>
            <div class="input-status" id="input-status"></div>
        </div>
        <div class="input-bar-buttons">
            <button class="send-btn" id="send-btn">
                <span>Send</span>
            </button>
            <button class="fork-btn hidden" id="fork-btn" title="Fork: create new session with conversation history">
                <span>Fork</span>
            </button>
            <button class="interrupt-btn hidden" id="interrupt-btn">
                <span>Stop</span>
            </button>
        </div>
    </div>

    <!-- Session tooltip (hidden, shown on hover) -->
    <div class="session-tooltip" id="session-tooltip" style="display: none;"></div>

    <!-- Message tooltip for token usage (hidden, shown on hover) -->
    <div class="message-tooltip" id="message-tooltip"></div>

    <!-- Flash message -->
    <div class="flash-message" id="flash-message"></div>

    <!-- New Session Modal -->
    <dialog id="new-session-modal" class="new-session-modal">
        <div class="modal-header">
            <h2>New Session</h2>
            <button class="modal-close-btn" id="modal-close-btn" type="button">&times;</button>
        </div>
        <form id="new-session-form" method="dialog">
            <div class="modal-field">
                <label for="modal-cwd">Working Directory</label>
                <input type="text" id="modal-cwd" class="modal-input" placeholder="/path/to/project" autocomplete="off">
            </div>
            <div class="modal-field">
                <label for="modal-backend">Backend</label>
                <select id="modal-backend" class="modal-select">
                    <option value="">Loading...</option>
                </select>
            </div>
            <div class="modal-field" id="modal-model-field" style="display: none;">
                <label for="modal-model">Model</label>
                <div class="model-select-wrapper">
                    <input type="text" id="modal-model-search" class="modal-input model-search" placeholder="Search models...">
                    <select id="modal-model" class="modal-select">
                        <option value="">(Default)</option>
                    </select>
                </div>
            </div>
            <div class="modal-buttons">
                <button type="button" class="modal-btn modal-btn-cancel" id="modal-cancel-btn">Cancel</button>
                <button type="submit" class="modal-btn modal-btn-create">Create Session</button>
            </div>
        </form>
    </dialog>

    <!-- Floating controls -->
    <div class="floating-controls" id="floating-controls">
        <button class="scroll-btn" id="scroll-top-btn" title="Scroll to top">&#8593;</button>
        <label class="auto-scroll-float" id="auto-scroll-float">
            <input type="checkbox" id="auto-scroll-checkbox" checked>
            <span>Auto</span>
        </label>
        <button class="scroll-btn" id="scroll-bottom-btn" title="Scroll to bottom">&#8595;</button>
    </div>

    <script>
    (function() {
        // DOM elements
        const sessionsContainer = document.getElementById('sessions');
        const projectListContainer = document.getElementById('project-list');
        const statusBar = document.getElementById('status-bar');
        const statusText = document.getElementById('status-text');
        const sessionTitleBar = document.getElementById('session-title-bar');
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const hamburgerBtn = document.getElementById('hamburger-btn');
        const autoSwitchCheckbox = document.getElementById('auto-switch');
        const autoSwitchLabel = document.getElementById('auto-switch-label');
        const sortSelect = document.getElementById('sort-select');
        const searchInput = document.getElementById('sidebar-search');
        const inputBar = document.getElementById('input-bar');
        const mainContent = document.getElementById('main-content');
        const messageInput = document.getElementById('message-input');
        const inputStatus = document.getElementById('input-status');
        const sendBtn = document.getElementById('send-btn');
        const forkBtn = document.getElementById('fork-btn');
        const interruptBtn = document.getElementById('interrupt-btn');
        const newSessionBtn = document.getElementById('new-session-btn');
        const sessionTooltip = document.getElementById('session-tooltip');
        const messageTooltip = document.getElementById('message-tooltip');
        const scrollTopBtn = document.getElementById('scroll-top-btn');
        const scrollBottomBtn = document.getElementById('scroll-bottom-btn');
        const autoScrollCheckbox = document.getElementById('auto-scroll-checkbox');
        const autoScrollFloat = document.getElementById('auto-scroll-float');
        const projectTitle = document.getElementById('project-title');
        const copyPathBtn = document.getElementById('copy-path-btn');
        const sessionIdBar = document.getElementById('session-id-bar');
        const sessionIdValue = document.getElementById('session-id-value');
        const copySessionBtn = document.getElementById('copy-session-btn');
        const flashMessage = document.getElementById('flash-message');

        // Modal elements
        const newSessionModal = document.getElementById('new-session-modal');
        const newSessionForm = document.getElementById('new-session-form');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const modalCwd = document.getElementById('modal-cwd');
        const modalBackend = document.getElementById('modal-backend');
        const modalModelField = document.getElementById('modal-model-field');
        const modalModel = document.getElementById('modal-model');
        const modalModelSearch = document.getElementById('modal-model-search');

        let currentProjectPath = null;
        let currentSessionId = null;

        let eventSource = null;
        const MAX_MESSAGES = 500;
        const MAX_TITLE_LENGTH = 50;

        // State
        const sessions = new Map();  // session_id -> session object
        const projects = new Map();  // project_name -> { name, sessions: Set, lastActivity, element }
        let activeSessionId = null;
        let sidebarOpen = localStorage.getItem('sidebarOpen') !== 'false';  // default open
        let autoSwitch = localStorage.getItem('autoSwitch') !== 'false';    // default on
        let autoScroll = localStorage.getItem('autoScroll') !== 'false';    // default on
        let sortBy = localStorage.getItem('sortBy') || 'modified';          // default: modified
        let autoSwitchDebounce = null;
        let catchupComplete = false;
        let sendEnabled = false;
        let forkEnabled = false;
        let defaultSendBackend = null;
        const sessionStatus = new Map();
        let pendingSessionCounter = 0;
        const pendingMessages = [];
        let tooltipTimeout = null;

        // Modal state
        let availableBackends = [];
        let cachedModels = {};  // backend_name -> [models]
        let allModelsForFilter = [];  // All models for the current backend

        // Check if mobile
        function isMobile() {
            return window.innerWidth <= 768;
        }

        // Date category helpers
        function getDateCategory(timestamp) {
            if (!timestamp) return 'older';
            const date = typeof timestamp === 'number' ? new Date(timestamp * 1000) : new Date(timestamp);
            if (isNaN(date.getTime())) return 'older';

            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            const lastWeek = new Date(today);
            lastWeek.setDate(lastWeek.getDate() - 7);

            const sessionDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());

            if (sessionDate >= today) return 'today';
            if (sessionDate >= yesterday) return 'yesterday';
            if (sessionDate >= lastWeek) return 'lastWeek';
            return 'older';
        }

        const dateCategoryLabels = {
            today: 'Today',
            yesterday: 'Yesterday',
            lastWeek: 'Past 7 Days',
            older: 'Older'
        };

        const dateCategoryOrder = ['today', 'yesterday', 'lastWeek', 'older'];

        // Get the sort timestamp for a session based on current sort mode
        function getSessionSortTimestamp(session) {
            if (sortBy === 'created') {
                // startedAt is ISO string, convert to ms
                return session.startedAt ? new Date(session.startedAt).getTime() : 0;
            }
            // Default: modified (lastActivity is already in ms)
            return session.lastActivity || 0;
        }

        // Get the timestamp for date categorization (for sidebar grouping)
        function getSessionCategoryTimestamp(session) {
            if (sortBy === 'created') {
                return session.startedAt;  // ISO string or null
            }
            return session.lastUpdatedAt;  // Unix seconds or null
        }

        // Sidebar toggle
        function updateSidebarState() {
            if (sidebarOpen) {
                sidebar.classList.remove('closed');
                mainContent.classList.remove('sidebar-closed');
                inputBar.classList.remove('sidebar-closed');
                if (isMobile()) {
                    sidebarOverlay.classList.add('visible');
                }
            } else {
                sidebar.classList.add('closed');
                mainContent.classList.add('sidebar-closed');
                inputBar.classList.add('sidebar-closed');
                sidebarOverlay.classList.remove('visible');
            }
            localStorage.setItem('sidebarOpen', sidebarOpen);
        }

        function toggleSidebar() {
            sidebarOpen = !sidebarOpen;
            updateSidebarState();
        }

        hamburgerBtn.addEventListener('click', toggleSidebar);
        sidebarOverlay.addEventListener('click', function() {
            sidebarOpen = false;
            updateSidebarState();
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            if (!isMobile()) {
                sidebarOverlay.classList.remove('visible');
            } else if (sidebarOpen) {
                sidebarOverlay.classList.add('visible');
            }
        });

        // Initialize sidebar state
        updateSidebarState();

        // Auto-switch UI
        function updateAutoSwitchUI() {
            autoSwitch = autoSwitchCheckbox.checked;
            if (autoSwitch) {
                autoSwitchLabel.classList.add('active');
            } else {
                autoSwitchLabel.classList.remove('active');
            }
            localStorage.setItem('autoSwitch', autoSwitch);
        }
        autoSwitchCheckbox.checked = autoSwitch;
        autoSwitchCheckbox.addEventListener('change', updateAutoSwitchUI);
        updateAutoSwitchUI();

        // Auto-scroll UI (floating controls)
        function updateAutoScrollUI() {
            autoScroll = autoScrollCheckbox.checked;
            if (autoScroll) {
                autoScrollFloat.classList.add('active');
            } else {
                autoScrollFloat.classList.remove('active');
            }
            localStorage.setItem('autoScroll', autoScroll);
        }
        autoScrollCheckbox.checked = autoScroll;
        autoScrollCheckbox.addEventListener('change', updateAutoScrollUI);
        updateAutoScrollUI();

        // Sort select UI
        sortSelect.value = sortBy;
        sortSelect.addEventListener('change', function() {
            sortBy = sortSelect.value;
            localStorage.setItem('sortBy', sortBy);
            reorderSidebar();
        });

        // Scroll buttons
        scrollTopBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
        scrollBottomBtn.addEventListener('click', function() {
            window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
        });

        // Search functionality
        function filterSidebar(query) {
            const lowerQuery = query.toLowerCase().trim();

            projects.forEach(function(project) {
                let projectHasMatch = false;

                project.sessions.forEach(function(sessionId) {
                    const session = sessions.get(sessionId);
                    if (!session) return;

                    if (!lowerQuery) {
                        session.sidebarItem.style.display = '';
                        projectHasMatch = true;
                        return;
                    }

                    const titleMatch = (session.displayTitle || '').toLowerCase().includes(lowerQuery);
                    const projectMatch = project.name.toLowerCase().includes(lowerQuery);
                    const contentMatch = session.container.textContent.toLowerCase().includes(lowerQuery);

                    if (titleMatch || projectMatch || contentMatch) {
                        session.sidebarItem.style.display = '';
                        projectHasMatch = true;
                    } else {
                        session.sidebarItem.style.display = 'none';
                    }
                });

                if (project.element) {
                    project.element.style.display = projectHasMatch ? '' : 'none';
                }
            });
        }

        searchInput.addEventListener('input', function() {
            filterSidebar(this.value);
        });

        // Send functionality
        async function checkSendEnabled() {
            try {
                const response = await fetch('/send-enabled');
                const data = await response.json();
                sendEnabled = data.enabled;
                if (sendEnabled) {
                    inputBar.classList.remove('hidden');
                } else {
                    inputBar.classList.add('hidden');
                }
            } catch (e) {
                console.error('Failed to check send-enabled:', e);
                sendEnabled = false;
            }
        }

        async function checkForkEnabled() {
            try {
                const response = await fetch('/fork-enabled');
                const data = await response.json();
                forkEnabled = data.enabled;
                updateForkButtonVisibility();
            } catch (e) {
                console.error('Failed to check fork-enabled:', e);
                forkEnabled = false;
            }
        }

        async function checkDefaultSendBackend() {
            try {
                const response = await fetch('/default-send-backend');
                const data = await response.json();
                defaultSendBackend = data.backend;
            } catch (e) {
                console.error('Failed to check default-send-backend:', e);
                defaultSendBackend = null;
            }
        }

        function updateForkButtonVisibility() {
            // Only show fork button on desktop and when fork is enabled
            if (forkEnabled && !isMobile()) {
                forkBtn.classList.remove('hidden');
            } else {
                forkBtn.classList.add('hidden');
            }
        }

        function updateInputBarUI() {
            const hasMessage = messageInput.value.trim();

            // Update fork button visibility (desktop only, when enabled)
            updateForkButtonVisibility();

            if (!activeSessionId) {
                sendBtn.disabled = true;
                forkBtn.disabled = true;
                inputStatus.textContent = '';
                inputStatus.className = 'input-status';
                sendBtn.classList.remove('hidden');
                interruptBtn.classList.add('hidden');
                return;
            }

            const session = sessions.get(activeSessionId);
            const status = sessionStatus.get(activeSessionId) || { running: false, queued_messages: 0 };

            if (session && session.pending && session.starting) {
                inputStatus.innerHTML = '<span class="spinner"></span> Starting session...';
                inputStatus.className = 'input-status running';
                sendBtn.classList.remove('hidden');
                sendBtn.disabled = true;
                forkBtn.disabled = true;
                interruptBtn.classList.add('hidden');
                return;
            }

            if (status.running) {
                inputStatus.className = 'input-status running';
                sendBtn.classList.add('hidden');
                interruptBtn.classList.remove('hidden');
                forkBtn.disabled = !hasMessage;

                if (status.queued_messages > 0) {
                    inputStatus.innerHTML = '<span class="spinner"></span> ' +
                        status.queued_messages + ' message' + (status.queued_messages > 1 ? 's' : '') + ' queued...';
                } else {
                    inputStatus.innerHTML = '<span class="spinner"></span> Claude is thinking...';
                }
            } else {
                inputStatus.textContent = '';
                inputStatus.className = 'input-status';
                sendBtn.classList.remove('hidden');
                interruptBtn.classList.add('hidden');
                forkBtn.disabled = !hasMessage;
            }

            sendBtn.disabled = !hasMessage;
        }

        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message || !activeSessionId) return;

            const session = sessions.get(activeSessionId);
            if (!session) return;

            sendBtn.disabled = true;

            if (session.pending) {
                await startPendingSession(session, message);
                return;
            }

            const placeholder = createPlaceholderMessage(activeSessionId, message);
            messageInput.value = '';
            autoResizeTextarea();

            try {
                const response = await fetch('/sessions/' + activeSessionId + '/send', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: message })
                });

                if (!response.ok) {
                    const data = await response.json();
                    alert('Error: ' + (data.detail || 'Failed to send message'));
                    if (placeholder) {
                        placeholder.element.remove();
                        const idx = pendingMessages.indexOf(placeholder);
                        if (idx > -1) pendingMessages.splice(idx, 1);
                    }
                }
            } catch (e) {
                alert('Error: Failed to send message');
                console.error('Send error:', e);
                if (placeholder) {
                    placeholder.element.remove();
                    const idx = pendingMessages.indexOf(placeholder);
                    if (idx > -1) pendingMessages.splice(idx, 1);
                }
            }

            updateInputBarUI();
        }

        function getBackendForNewSession(pendingSession) {
            // Priority: pendingSession.selectedBackend -> defaultSendBackend -> current session's backend -> null
            if (pendingSession && pendingSession.selectedBackend) {
                return pendingSession.selectedBackend;
            }
            if (defaultSendBackend) return defaultSendBackend;
            if (activeSessionId) {
                const session = sessions.get(activeSessionId);
                if (session && session.backend) return session.backend;
            }
            return null;
        }

        async function startPendingSession(pendingSession, message) {
            inputStatus.innerHTML = '<span class="spinner"></span> Starting session...';
            inputStatus.className = 'input-status running';

            try {
                const backend = getBackendForNewSession(pendingSession);
                const modelIndex = pendingSession.selectedModelIndex;

                const requestBody = {
                    message: message,
                    cwd: pendingSession.cwd || null,
                    backend: backend
                };

                // Only include model_index if it's set (some backends don't support it)
                if (modelIndex !== null && modelIndex !== undefined) {
                    requestBody.model_index = modelIndex;
                }

                const response = await fetch('/sessions/new', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (response.ok) {
                    messageInput.value = '';
                    autoResizeTextarea();
                    pendingSession.starting = true;
                    pendingSession.startedAt = Date.now();
                } else {
                    const data = await response.json();
                    alert('Error: ' + (data.detail || 'Failed to start session'));
                    inputStatus.textContent = '';
                    inputStatus.className = 'input-status';
                }
            } catch (e) {
                alert('Error: Failed to start session');
                console.error('New session error:', e);
                inputStatus.textContent = '';
                inputStatus.className = 'input-status';
            }

            updateInputBarUI();
        }

        async function interruptSession() {
            if (!activeSessionId) return;

            try {
                const response = await fetch('/sessions/' + activeSessionId + '/interrupt', {
                    method: 'POST'
                });

                if (response.ok) {
                    showFlash('Session interrupted', 'success');
                } else {
                    const data = await response.json();
                    console.error('Interrupt failed:', data.detail);
                    // Show user-friendly message based on error
                    if (response.status === 409) {
                        showFlash('Process not running yet, try again', 'warning');
                    } else {
                        showFlash('Failed to stop: ' + (data.detail || 'Unknown error'), 'error');
                    }
                }
            } catch (e) {
                console.error('Interrupt error:', e);
                showFlash('Failed to stop session', 'error');
            }
        }

        async function forkMessage() {
            // Fork: create a new session with the conversation history using --fork-session
            const message = messageInput.value.trim();
            if (!message || !activeSessionId) return;

            const session = sessions.get(activeSessionId);
            if (!session) return;

            // Don't allow forking pending sessions
            if (session.pending) {
                alert('Cannot fork a pending session. Send a message first to create the session.');
                return;
            }

            forkBtn.disabled = true;
            inputStatus.innerHTML = '<span class="spinner"></span> Forking session...';
            inputStatus.className = 'input-status running';

            try {
                const response = await fetch('/sessions/' + activeSessionId + '/fork', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: message })
                });

                if (response.ok) {
                    messageInput.value = '';
                    autoResizeTextarea();
                    inputStatus.textContent = '';
                    inputStatus.className = 'input-status';
                    // The new forked session will appear via SSE and auto-switch will handle it
                } else {
                    const data = await response.json();
                    alert('Error: ' + (data.detail || 'Failed to fork session'));
                    inputStatus.textContent = '';
                    inputStatus.className = 'input-status';
                }
            } catch (e) {
                alert('Error: Failed to fork session');
                console.error('Fork error:', e);
                inputStatus.textContent = '';
                inputStatus.className = 'input-status';
            }

            updateInputBarUI();
        }

        function autoResizeTextarea() {
            messageInput.style.height = 'auto';
            messageInput.style.height = Math.min(messageInput.scrollHeight, 120) + 'px';
        }

        let flashTimeout = null;
        function showFlash(message, type = 'info', duration = 3000) {
            // Clear any existing timeout
            if (flashTimeout) {
                clearTimeout(flashTimeout);
            }
            // Set content and type
            flashMessage.textContent = message;
            flashMessage.className = 'flash-message ' + type;
            // Show
            requestAnimationFrame(() => {
                flashMessage.classList.add('visible');
            });
            // Auto-hide
            flashTimeout = setTimeout(() => {
                flashMessage.classList.remove('visible');
            }, duration);
        }

        messageInput.addEventListener('input', function() {
            autoResizeTextarea();
            updateInputBarUI();
        });

        messageInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (!sendBtn.disabled && !sendBtn.classList.contains('hidden')) {
                    sendMessage();
                }
            }
        });

        sendBtn.addEventListener('click', sendMessage);
        forkBtn.addEventListener('click', forkMessage);
        interruptBtn.addEventListener('click', interruptSession);

        // New session functionality
        function createPendingSession(cwd, projectName, backend, modelIndex, modelName) {
            pendingSessionCounter++;
            const pendingId = 'pending-' + pendingSessionCounter;

            // Use provided cwd/projectName, or fall back to active session's project
            if (!cwd && activeSessionId) {
                const activeSession = sessions.get(activeSessionId);
                if (activeSession && activeSession.cwd) {
                    cwd = activeSession.cwd;
                    projectName = projectName || activeSession.projectName;
                }
            }

            const displayProjectName = projectName || 'New Session';
            const session = createSession(pendingId, 'New Session', displayProjectName, null, null, null, cwd, null, null);
            session.pending = true;
            session.cwd = cwd;
            session.selectedBackend = backend || null;
            session.selectedModelIndex = modelIndex;  // Integer index or null

            session.sidebarItem.classList.add('pending');
            const backendInfo = backend ? ' using <strong>' + escapeHtml(backend) + '</strong>' : '';
            const modelInfo = modelName ? ' (' + escapeHtml(modelName) + ')' : '';
            session.container.innerHTML = '<div class="pending-session-placeholder">' +
                '<p>Type a message below to start this session' +
                (cwd ? ' in <strong>' + escapeHtml(displayProjectName) + '</strong>' : '') +
                backendInfo + modelInfo +
                '</p></div>';

            switchToSession(pendingId);
            messageInput.focus();

            // Close sidebar on mobile after selecting
            if (isMobile()) {
                sidebarOpen = false;
                updateSidebarState();
            }
        }

        // Modal functions
        async function loadBackends() {
            try {
                const response = await fetch('/backends');
                if (response.ok) {
                    const data = await response.json();
                    availableBackends = data.backends || [];
                }
            } catch (e) {
                console.error('Failed to load backends:', e);
                availableBackends = [];
            }
        }

        async function loadModelsForBackend(backendName) {
            // Check cache first
            if (cachedModels[backendName]) {
                return cachedModels[backendName];
            }

            try {
                const response = await fetch('/backends/' + encodeURIComponent(backendName) + '/models');
                if (response.ok) {
                    const data = await response.json();
                    cachedModels[backendName] = data.models || [];
                    return cachedModels[backendName];
                }
            } catch (e) {
                console.error('Failed to load models for ' + backendName + ':', e);
            }
            return [];
        }

        function populateBackendSelect() {
            modalBackend.innerHTML = '';

            if (availableBackends.length === 0) {
                modalBackend.innerHTML = '<option value="">No backends available</option>';
                return;
            }

            // Get saved backend preference
            const savedBackend = localStorage.getItem('newSessionBackend') || '';

            availableBackends.forEach(function(backend) {
                const option = document.createElement('option');
                option.value = backend.name;
                option.textContent = backend.name;
                if (!backend.cli_available) {
                    option.textContent += ' (CLI not available)';
                    option.disabled = true;
                }
                if (backend.name === savedBackend || (!savedBackend && backend.cli_available)) {
                    option.selected = true;
                }
                modalBackend.appendChild(option);
            });
        }

        async function populateModelSelect(backendName) {
            // Find the backend info
            const backend = availableBackends.find(function(b) { return b.name === backendName; });

            if (!backend || !backend.supports_models) {
                modalModelField.style.display = 'none';
                allModelsForFilter = [];
                return;
            }

            modalModelField.style.display = 'block';
            modalModel.innerHTML = '<option value="">(Default)</option>';
            modalModelSearch.value = '';

            const models = await loadModelsForBackend(backendName);
            allModelsForFilter = models;

            // Get saved model preference for this backend
            const savedModel = localStorage.getItem('newSessionModel_' + backendName) || '';

            models.forEach(function(model) {
                const option = document.createElement('option');
                option.value = model;
                option.textContent = model;
                if (model === savedModel) {
                    option.selected = true;
                }
                modalModel.appendChild(option);
            });
        }

        function filterModels(searchText) {
            const search = searchText.toLowerCase();
            modalModel.innerHTML = '<option value="">(Default)</option>';

            const savedBackend = modalBackend.value;
            const savedModel = localStorage.getItem('newSessionModel_' + savedBackend) || '';

            allModelsForFilter.forEach(function(model) {
                if (!search || model.toLowerCase().includes(search)) {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    if (model === savedModel) {
                        option.selected = true;
                    }
                    modalModel.appendChild(option);
                }
            });
        }

        async function openNewSessionModal() {
            // Load backends if not already loaded
            if (availableBackends.length === 0) {
                await loadBackends();
            }

            // Get a default directory from active session if available
            let defaultDir = '';
            if (activeSessionId) {
                const activeSession = sessions.get(activeSessionId);
                if (activeSession && activeSession.cwd) {
                    defaultDir = activeSession.cwd;
                }
            }

            // Load saved cwd or use default
            const savedCwd = localStorage.getItem('newSessionCwd');
            modalCwd.value = savedCwd || defaultDir;

            // Populate backend select
            populateBackendSelect();

            // Populate model select for the selected backend
            await populateModelSelect(modalBackend.value);

            // Show modal
            newSessionModal.showModal();
            modalCwd.focus();
        }

        function closeNewSessionModal() {
            newSessionModal.close();
        }

        function handleNewSessionSubmit(e) {
            e.preventDefault();

            const cwd = modalCwd.value.trim();
            if (!cwd) {
                alert('Please enter a directory path');
                return;
            }

            const backend = modalBackend.value;
            const modelSelect = modalModel;
            const modelIndex = modelSelect.selectedIndex > 0 ? modelSelect.selectedIndex - 1 : null;  // -1 for "(Default)" option
            const modelName = modelIndex !== null ? modelSelect.value : null;

            // Save preferences to localStorage
            localStorage.setItem('newSessionCwd', cwd);
            if (backend) {
                localStorage.setItem('newSessionBackend', backend);
            }
            if (backend && modelName) {
                localStorage.setItem('newSessionModel_' + backend, modelName);
            }

            // Extract project name from path (last component)
            const projectName = cwd.split('/').filter(function(s) { return s; }).pop() || 'New Session';

            // Close modal
            closeNewSessionModal();

            // Create pending session with backend/model info stored
            createPendingSession(cwd, projectName, backend, modelIndex, modelName);
        }

        // Event listeners for modal
        modalBackend.addEventListener('change', function() {
            populateModelSelect(modalBackend.value);
        });

        modalModelSearch.addEventListener('input', function() {
            filterModels(modalModelSearch.value);
        });

        modalCloseBtn.addEventListener('click', closeNewSessionModal);
        modalCancelBtn.addEventListener('click', closeNewSessionModal);

        newSessionForm.addEventListener('submit', handleNewSessionSubmit);

        // Close modal on backdrop click
        newSessionModal.addEventListener('click', function(e) {
            if (e.target === newSessionModal) {
                closeNewSessionModal();
            }
        });

        newSessionBtn.addEventListener('click', openNewSessionModal);

        // Copy button handlers
        function copyToClipboard(text, btn) {
            // Try modern clipboard API first, fall back to execCommand for non-HTTPS
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(function() {
                    showCopySuccess(btn);
                }).catch(function() {
                    fallbackCopy(text, btn);
                });
            } else {
                fallbackCopy(text, btn);
            }
        }

        function fallbackCopy(text, btn) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showCopySuccess(btn);
            } catch (err) {
                console.error('Failed to copy:', err);
            }
            document.body.removeChild(textarea);
        }

        function showCopySuccess(btn) {
            if (btn) {
                btn.classList.add('copied');
                setTimeout(function() {
                    btn.classList.remove('copied');
                }, 1500);
            }
        }

        copyPathBtn.addEventListener('click', function() {
            if (currentProjectPath) {
                copyToClipboard(currentProjectPath, copyPathBtn);
            }
        });

        copySessionBtn.addEventListener('click', function() {
            if (currentSessionId) {
                copyToClipboard(currentSessionId, copySessionBtn);
            }
        });

        function updateStatus(status, text) {
            statusBar.className = 'status-bar ' + status;
            statusText.textContent = text;
        }

        function isNearBottom() {
            const threshold = 150;
            return (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - threshold);
        }

        function processNewElement(element) {
            element.querySelectorAll('time[data-timestamp]').forEach(function(el) {
                const timestamp = el.getAttribute('data-timestamp');
                const date = new Date(timestamp);
                const now = new Date();
                const isToday = date.toDateString() === now.toDateString();
                const timeStr = date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
                if (isToday) { el.textContent = timeStr; }
                else { el.textContent = date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) + ' ' + timeStr; }
            });

            element.querySelectorAll('pre.json').forEach(function(el) {
                let text = el.textContent;
                text = text.replace(/"([^"]+)":/g, '<span style="color: #ce93d8">"$1"</span>:');
                text = text.replace(/: "([^"]*)"/g, ': <span style="color: #81d4fa">"$1"</span>');
                text = text.replace(/: (\d+)/g, ': <span style="color: #ffcc80">$1</span>');
                text = text.replace(/: (true|false|null)/g, ': <span style="color: #f48fb1">$1</span>');
                el.innerHTML = text;
            });

            element.querySelectorAll('.truncatable').forEach(function(wrapper) {
                const content = wrapper.querySelector('.truncatable-content');
                const btn = wrapper.querySelector('.expand-btn');
                if (content && btn && content.scrollHeight > 250) {
                    wrapper.classList.add('truncated');
                    btn.addEventListener('click', function() {
                        if (wrapper.classList.contains('truncated')) {
                            wrapper.classList.remove('truncated');
                            wrapper.classList.add('expanded');
                            btn.textContent = 'Show less';
                        } else {
                            wrapper.classList.remove('expanded');
                            wrapper.classList.add('truncated');
                            btn.textContent = 'Show more';
                        }
                    });
                }
            });

            // Add tooltip handlers for assistant messages with usage data
            // Check both the element itself and its descendants
            const assistantMessages = [];
            if (element.matches && element.matches('.message.assistant[data-usage-input]')) {
                assistantMessages.push(element);
            }
            element.querySelectorAll('.message.assistant[data-usage-input]').forEach(function(msg) {
                assistantMessages.push(msg);
            });
            assistantMessages.forEach(function(msg) {
                const header = msg.querySelector('.message-header');
                if (header) {
                    header.addEventListener('mouseenter', function(e) {
                        showMessageTooltip(msg, e);
                    });
                    header.addEventListener('mouseleave', hideMessageTooltip);
                    header.addEventListener('mousemove', function(e) {
                        positionMessageTooltip(e);
                    });
                }
            });

        }

        let messageTooltipTimeout = null;

        function formatModelName(model) {
            if (!model) return '';
            // Format 1: claude-opus-4-5-20251101 -> "Opus 4.5"
            // Format 2: claude-sonnet-4-20250514 -> "Sonnet 4"
            let match = model.match(/claude-(\w+)-(\d+)(?:-(\d+))?-\d{8}/);
            if (match) {
                const name = match[1].charAt(0).toUpperCase() + match[1].slice(1);
                const version = match[3] ? `${match[2]}.${match[3]}` : match[2];
                return `${name} ${version}`;
            }
            // Format 3: claude-3-7-sonnet-20250219 -> "Sonnet 3.7"
            match = model.match(/claude-(\d+)(?:-(\d+))?-(\w+)-\d{8}/);
            if (match) {
                const name = match[3].charAt(0).toUpperCase() + match[3].slice(1);
                const version = match[2] ? `${match[1]}.${match[2]}` : match[1];
                return `${name} ${version}`;
            }
            return model;
        }

        function showMessageTooltip(msgEl, e) {
            if (messageTooltipTimeout) clearTimeout(messageTooltipTimeout);

            messageTooltipTimeout = setTimeout(function() {
                const input = parseInt(msgEl.dataset.usageInput) || 0;
                const output = parseInt(msgEl.dataset.usageOutput) || 0;
                const cacheCreate = parseInt(msgEl.dataset.usageCacheCreate) || 0;
                const cacheRead = parseInt(msgEl.dataset.usageCacheRead) || 0;
                const cost = parseFloat(msgEl.dataset.usageCost) || 0;
                const model = msgEl.dataset.model || '';

                let modelHtml = '';
                if (model) {
                    modelHtml = `<div class="usage-row model-row"><span class="usage-label">Model:</span>${escapeHtml(formatModelName(model))}</div>`;
                }

                messageTooltip.innerHTML = `
                    ${modelHtml}
                    <div class="usage-row">
                        <span class="usage-item"><span class="usage-label">In:</span>${formatTokenCount(input)}</span>
                        <span class="usage-item"><span class="usage-label">Out:</span>${formatTokenCount(output)}</span>
                        <span class="usage-item"><span class="usage-label">Cache↑:</span>${formatTokenCount(cacheCreate)}</span>
                        <span class="usage-item"><span class="usage-label">Cache↓:</span>${formatTokenCount(cacheRead)}</span>
                        <span class="usage-item"><span class="usage-label">Cost:</span>${formatCost(cost)}</span>
                    </div>
                `;
                // Position first with visibility hidden to measure, then show
                messageTooltip.style.visibility = 'hidden';
                messageTooltip.style.display = 'block';
                positionMessageTooltip(e);
                messageTooltip.style.visibility = 'visible';
            }, 200);
        }

        function positionMessageTooltip(e) {
            const padding = 10;
            let left = e.clientX + padding;
            let top = e.clientY + padding;

            // Get dimensions after rendering
            const rect = messageTooltip.getBoundingClientRect();
            if (rect.width > 0 && left + rect.width > window.innerWidth) {
                left = e.clientX - rect.width - padding;
            }
            if (rect.height > 0 && top + rect.height > window.innerHeight) {
                top = e.clientY - rect.height - padding;
            }

            messageTooltip.style.left = left + 'px';
            messageTooltip.style.top = top + 'px';
        }

        function hideMessageTooltip() {
            if (messageTooltipTimeout) {
                clearTimeout(messageTooltipTimeout);
                messageTooltipTimeout = null;
            }
            messageTooltip.style.display = 'none';
        }

        function formatTimestamp(ts) {
            if (!ts) return 'Unknown';
            const date = typeof ts === 'number' ? new Date(ts * 1000) : new Date(ts);
            if (isNaN(date.getTime())) return 'Unknown';
            const now = new Date();
            const isToday = date.toDateString() === now.toDateString();
            const timeStr = date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
            if (isToday) {
                return 'Today ' + timeStr;
            }
            return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) + ' ' + timeStr;
        }

        function truncateTitle(text, maxLength) {
            if (!text) return 'Untitled';
            // Remove newlines and excess whitespace
            text = text.replace(/\s+/g, ' ').trim();
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        }

        function getOrCreateProject(projectName, projectPath) {
            if (projects.has(projectName)) {
                const project = projects.get(projectName);
                // Update path if we have a better one
                if (projectPath && !project.path) {
                    project.path = projectPath;
                }
                return project;
            }

            const projectItem = document.createElement('div');
            projectItem.className = 'project-item';

            // Build date sections HTML
            let dateSectionsHtml = '';
            dateCategoryOrder.forEach(function(category) {
                const isOpen = category === 'today' || category === 'yesterday';
                dateSectionsHtml += `
                    <div class="date-section${isOpen ? '' : ' collapsed'}" data-category="${category}">
                        <div class="date-divider">
                            <span class="date-label">${dateCategoryLabels[category]}</span>
                        </div>
                        <div class="date-session-list"></div>
                    </div>
                `;
            });

            projectItem.innerHTML = `
                <div class="project-header">
                    <span class="project-icon">&#9660;</span>
                    <span class="unread-dot"></span>
                    <span class="project-name">${escapeHtml(projectName)}</span>
                    <button class="project-new-btn" title="New session in ${escapeHtml(projectName)}">+</button>
                </div>
                <div class="session-list">${dateSectionsHtml}</div>
            `;

            const projectHeader = projectItem.querySelector('.project-header');
            const projectNewBtn = projectItem.querySelector('.project-new-btn');

            projectHeader.addEventListener('click', function(e) {
                // Don't toggle when clicking the new button
                if (e.target === projectNewBtn) return;
                projectItem.classList.toggle('collapsed');
                // Track if user manually expanded, so we don't auto-collapse
                if (!projectItem.classList.contains('collapsed')) {
                    projectItem.classList.add('user-expanded');
                } else {
                    projectItem.classList.remove('user-expanded');
                }
            });

            projectNewBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                createPendingSession(projectPath || null, projectName);
            });

            // Date section toggle handlers and tooltips
            projectItem.querySelectorAll('.date-divider').forEach(function(divider) {
                divider.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const section = divider.parentElement;
                    section.classList.toggle('collapsed');
                });
                // Add tooltip handlers for date sections
                divider.addEventListener('mouseenter', function(e) {
                    const section = divider.parentElement;
                    const category = section.dataset.category;
                    showDateCategoryTooltip(projectName, category, e);
                });
                divider.addEventListener('mouseleave', hideTooltip);
                divider.addEventListener('mousemove', positionTooltip);
            });

            projectListContainer.appendChild(projectItem);

            // Build dateSections map
            const dateSections = {};
            dateCategoryOrder.forEach(function(category) {
                const section = projectItem.querySelector(`.date-section[data-category="${category}"]`);
                dateSections[category] = {
                    element: section,
                    listElement: section.querySelector('.date-session-list')
                };
            });

            const project = {
                name: projectName,
                path: projectPath || null,
                sessions: new Set(),
                lastActivity: 0,
                element: projectItem,
                sessionListElement: projectItem.querySelector('.session-list'),
                dateSections: dateSections
            };
            projects.set(projectName, project);

            return project;
        }

        function createSession(sessionId, name, projectName, firstMessage, startedAt, lastUpdatedAt, projectPath, tokenUsage, backend) {
            if (sessions.has(sessionId)) return sessions.get(sessionId);

            // Create container with session header
            const container = document.createElement('div');
            container.className = 'session-container';
            container.dataset.session = sessionId;
            if (backend) container.dataset.backend = backend;

            const displayTitle = truncateTitle(firstMessage || name, MAX_TITLE_LENGTH);

            // Add session header (title only - auto-scroll is in floating controls)
            const sessionHeader = document.createElement('div');
            sessionHeader.className = 'session-header';
            sessionHeader.innerHTML = `<span class="session-title-display">${escapeHtml(displayTitle)}</span>`;
            container.appendChild(sessionHeader);

            sessionsContainer.appendChild(container);

            // Create sidebar item
            const sidebarItem = document.createElement('div');
            sidebarItem.className = 'session-item';
            sidebarItem.dataset.session = sessionId;
            if (backend) sidebarItem.dataset.backend = backend;

            sidebarItem.innerHTML = `
                <span class="unread-dot"></span>
                <span class="session-title">${escapeHtml(displayTitle)}</span>
                <span class="close-btn" title="Close">&times;</span>
            `;

            sidebarItem.addEventListener('click', function(e) {
                if (e.target.classList.contains('close-btn')) {
                    removeSession(sessionId);
                } else {
                    switchToSession(sessionId, true);  // Scroll to bottom when opening
                    // Close sidebar on mobile
                    if (isMobile()) {
                        sidebarOpen = false;
                        updateSidebarState();
                    }
                }
            });

            // Tooltip handlers
            sidebarItem.addEventListener('mouseenter', function(e) {
                showTooltip(sessionId, e);
            });
            sidebarItem.addEventListener('mouseleave', hideTooltip);
            sidebarItem.addEventListener('mousemove', function(e) {
                positionTooltip(e);
            });

            // Add to project in appropriate date section
            const project = getOrCreateProject(projectName || 'Unknown', projectPath);
            project.sessions.add(sessionId);

            // Determine date category and add to correct section (respecting sort mode)
            const categoryTimestamp = sortBy === 'created' ? startedAt : lastUpdatedAt;
            const dateCategory = getDateCategory(categoryTimestamp);
            const dateSection = project.dateSections[dateCategory];
            if (dateSection) {
                dateSection.listElement.appendChild(sidebarItem);
            }

            const session = {
                id: sessionId,
                name: name,
                projectName: projectName || 'Unknown',
                displayTitle: displayTitle,
                firstMessage: firstMessage,
                container: container,
                sidebarItem: sidebarItem,
                messageCount: 0,
                lastActivity: lastUpdatedAt ? lastUpdatedAt * 1000 : Date.now(),
                startedAt: startedAt || null,
                lastUpdatedAt: lastUpdatedAt || null,
                cwd: projectPath || null,
                tokenUsage: tokenUsage || null,
                backend: backend || null
            };
            sessions.set(sessionId, session);

            // Update project's last activity
            project.lastActivity = Math.max(project.lastActivity, session.lastActivity);

            // If this is the first session, activate it
            if (sessions.size === 1) {
                switchToSession(sessionId);
            }

            return session;
        }

        function formatTokenCount(count) {
            if (!count || count === 0) return '0';
            if (count >= 1000000) {
                return (count / 1000000).toFixed(1) + 'M';
            } else if (count >= 1000) {
                return (count / 1000).toFixed(1) + 'K';
            }
            return count.toString();
        }

        function formatCost(cost) {
            if (!cost || cost === 0) return '$0.00';
            if (cost < 0.01) return '<$0.01';
            return '$' + cost.toFixed(2);
        }

        function showDateCategoryTooltip(projectName, category, e) {
            const project = projects.get(projectName);
            if (!project) return;

            if (tooltipTimeout) clearTimeout(tooltipTimeout);

            tooltipTimeout = setTimeout(function() {
                // Aggregate stats for sessions in this date category
                let totalInput = 0, totalOutput = 0, totalCacheCreate = 0, totalCacheRead = 0, totalCost = 0;
                let sessionCount = 0;

                project.sessions.forEach(function(sessionId) {
                    const session = sessions.get(sessionId);
                    if (!session) return;
                    const sessionCategory = getDateCategory(session.lastUpdatedAt);
                    if (sessionCategory !== category) return;

                    sessionCount++;
                    if (session.tokenUsage) {
                        totalInput += session.tokenUsage.input_tokens || 0;
                        totalOutput += session.tokenUsage.output_tokens || 0;
                        totalCacheCreate += session.tokenUsage.cache_creation_tokens || 0;
                        totalCacheRead += session.tokenUsage.cache_read_tokens || 0;
                        totalCost += session.tokenUsage.cost || 0;
                    }
                });

                if (sessionCount === 0) {
                    hideTooltip();
                    return;
                }

                const categoryLabel = dateCategoryLabels[category] || category;

                sessionTooltip.innerHTML = `
                    <div class="tooltip-label">${escapeHtml(categoryLabel)} - ${escapeHtml(projectName)}</div>
                    <div class="tooltip-value">${sessionCount} session${sessionCount !== 1 ? 's' : ''}</div>
                    <div class="tooltip-label">Token Usage</div>
                    <div class="tooltip-value tooltip-usage">
                        <span class="usage-item">In: ${formatTokenCount(totalInput)}</span>
                        <span class="usage-item">Out: ${formatTokenCount(totalOutput)}</span>
                        <span class="usage-item">Cache↑: ${formatTokenCount(totalCacheCreate)}</span>
                        <span class="usage-item">Cache↓: ${formatTokenCount(totalCacheRead)}</span>
                    </div>
                    <div class="tooltip-label">Estimated Cost</div>
                    <div class="tooltip-value tooltip-cost">${formatCost(totalCost)}</div>
                `;
                sessionTooltip.style.display = 'block';
                positionTooltip(e);
            }, 300);
        }

        function showTooltip(sessionId, e) {
            const session = sessions.get(sessionId);
            if (!session) return;

            if (tooltipTimeout) clearTimeout(tooltipTimeout);

            tooltipTimeout = setTimeout(function() {
                const started = formatTimestamp(session.startedAt);
                const updated = formatTimestamp(session.lastUpdatedAt);
                const fullMessage = session.firstMessage || 'No message';

                let backendHtml = '';
                if (session.backend) {
                    backendHtml = `
                        <div class="tooltip-label">Backend</div>
                        <div class="tooltip-value">${escapeHtml(session.backend)}</div>
                    `;
                }

                let usageHtml = '';
                if (session.tokenUsage && session.tokenUsage.message_count > 0) {
                    const u = session.tokenUsage;
                    let modelsHtml = '';
                    if (u.models && u.models.length > 0) {
                        const modelNames = u.models.map(formatModelName).join(', ');
                        modelsHtml = `
                            <div class="tooltip-label">Models</div>
                            <div class="tooltip-value tooltip-models">${escapeHtml(modelNames)}</div>
                        `;
                    }
                    usageHtml = `
                        ${modelsHtml}
                        <div class="tooltip-label">Token Usage</div>
                        <div class="tooltip-value tooltip-usage">
                            <span class="usage-item">In: ${formatTokenCount(u.input_tokens)}</span>
                            <span class="usage-item">Out: ${formatTokenCount(u.output_tokens)}</span>
                            <span class="usage-item">Cache↑: ${formatTokenCount(u.cache_creation_tokens)}</span>
                            <span class="usage-item">Cache↓: ${formatTokenCount(u.cache_read_tokens)}</span>
                        </div>
                        <div class="tooltip-label">Estimated Cost</div>
                        <div class="tooltip-value tooltip-cost">${formatCost(u.cost)}</div>
                    `;
                }

                sessionTooltip.innerHTML = `
                    ${backendHtml}
                    <div class="tooltip-label">Created</div>
                    <div class="tooltip-value">${escapeHtml(started)}</div>
                    <div class="tooltip-label">Last updated</div>
                    <div class="tooltip-value">${escapeHtml(updated)}</div>
                    ${usageHtml}
                    <div class="tooltip-label">First message</div>
                    <div class="tooltip-value tooltip-message">${escapeHtml(fullMessage)}</div>
                `;
                sessionTooltip.style.display = 'block';
                positionTooltip(e);
            }, 300);
        }

        function positionTooltip(e) {
            const tooltip = sessionTooltip;
            const padding = 10;

            let left = e.clientX + padding;
            let top = e.clientY + padding;

            // Adjust if tooltip goes off-screen
            const rect = tooltip.getBoundingClientRect();
            if (left + rect.width > window.innerWidth) {
                left = e.clientX - rect.width - padding;
            }
            if (top + rect.height > window.innerHeight) {
                top = e.clientY - rect.height - padding;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        function hideTooltip() {
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
                tooltipTimeout = null;
            }
            sessionTooltip.style.display = 'none';
        }

        function removeSession(sessionId) {
            const session = sessions.get(sessionId);
            if (!session) return;

            // Remove from project
            const project = projects.get(session.projectName);
            if (project) {
                project.sessions.delete(sessionId);
                // Remove project if empty
                if (project.sessions.size === 0) {
                    project.element.remove();
                    projects.delete(session.projectName);
                }
            }

            session.container.remove();
            session.sidebarItem.remove();
            sessions.delete(sessionId);

            if (activeSessionId === sessionId) {
                const firstSession = sessions.keys().next().value;
                if (firstSession) {
                    switchToSession(firstSession);
                } else {
                    activeSessionId = null;
                }
            }
        }

        function reorderSidebar() {
            // FLIP animation: capture positions before reorder
            const projectPositions = new Map();
            const sessionPositions = new Map();

            projects.forEach(function(project) {
                projectPositions.set(project.name, project.element.getBoundingClientRect());
            });
            sessions.forEach(function(session) {
                sessionPositions.set(session.id, session.sidebarItem.getBoundingClientRect());
            });

            // Sort projects by most recent session (based on sort mode)
            const sortedProjects = Array.from(projects.values()).sort(function(a, b) {
                const aMax = Array.from(a.sessions)
                    .map(id => sessions.get(id))
                    .filter(s => s)
                    .reduce((max, s) => Math.max(max, getSessionSortTimestamp(s)), 0);
                const bMax = Array.from(b.sessions)
                    .map(id => sessions.get(id))
                    .filter(s => s)
                    .reduce((max, s) => Math.max(max, getSessionSortTimestamp(s)), 0);
                return bMax - aMax;
            });

            sortedProjects.forEach(function(project) {
                projectListContainer.appendChild(project.element);

                // Group sessions by date category
                const sessionsByCategory = {};
                dateCategoryOrder.forEach(function(cat) { sessionsByCategory[cat] = []; });

                Array.from(project.sessions)
                    .map(id => sessions.get(id))
                    .filter(s => s)
                    .forEach(function(session) {
                        const category = getDateCategory(getSessionCategoryTimestamp(session));
                        sessionsByCategory[category].push(session);
                    });

                // Sort and place sessions within each date category
                dateCategoryOrder.forEach(function(category) {
                    const dateSection = project.dateSections[category];
                    const categorySessions = sessionsByCategory[category]
                        .sort((a, b) => getSessionSortTimestamp(b) - getSessionSortTimestamp(a));

                    // Show/hide date section based on whether it has sessions
                    if (categorySessions.length === 0) {
                        dateSection.element.classList.add('empty');
                    } else {
                        dateSection.element.classList.remove('empty');
                        categorySessions.forEach(function(session) {
                            dateSection.listElement.appendChild(session.sidebarItem);
                        });
                    }
                });

                // Collapse project if no sessions in "today"
                const todaySessions = sessionsByCategory['today'];
                if (todaySessions.length === 0 && !project.element.classList.contains('user-expanded')) {
                    project.element.classList.add('collapsed');
                }
            });

            // FLIP animation: animate from old to new positions
            projects.forEach(function(project) {
                const oldRect = projectPositions.get(project.name);
                const newRect = project.element.getBoundingClientRect();
                if (oldRect && Math.abs(oldRect.top - newRect.top) > 1) {
                    const deltaY = oldRect.top - newRect.top;
                    project.element.style.transform = `translateY(${deltaY}px)`;
                    project.element.style.transition = 'none';
                    requestAnimationFrame(function() {
                        project.element.style.transition = 'transform 0.2s ease-out';
                        project.element.style.transform = '';
                    });
                }
            });

            sessions.forEach(function(session) {
                const oldRect = sessionPositions.get(session.id);
                const newRect = session.sidebarItem.getBoundingClientRect();
                if (oldRect && Math.abs(oldRect.top - newRect.top) > 1) {
                    const deltaY = oldRect.top - newRect.top;
                    session.sidebarItem.style.transform = `translateY(${deltaY}px)`;
                    session.sidebarItem.style.transition = 'none';
                    requestAnimationFrame(function() {
                        session.sidebarItem.style.transition = 'transform 0.2s ease-out';
                        session.sidebarItem.style.transform = '';
                    });
                }
            });
        }

        function switchToSession(sessionId, scrollToBottom = false) {
            const session = sessions.get(sessionId);
            if (!session) return;

            // Update containers
            sessions.forEach(function(s) {
                s.container.classList.remove('active');
                s.sidebarItem.classList.remove('active');
            });
            session.container.classList.add('active');
            session.sidebarItem.classList.add('active');
            activeSessionId = sessionId;

            // Clear unread/waiting state
            session.sidebarItem.classList.remove('unread', 'waiting');
            updateProjectUnreadState(session.projectName);

            // Update header title
            sessionTitleBar.textContent = session.displayTitle || session.name;

            // Update project title and session ID
            projectTitle.textContent = session.projectName || 'Unknown Project';
            currentProjectPath = session.cwd;
            currentSessionId = session.pending ? null : sessionId;

            if (currentProjectPath) {
                copyPathBtn.style.display = '';
            } else {
                copyPathBtn.style.display = 'none';
            }

            if (currentSessionId && !session.pending) {
                sessionIdValue.textContent = currentSessionId;
                sessionIdBar.style.display = '';
            } else {
                sessionIdBar.style.display = 'none';
            }

            updateInputBarUI();

            if (scrollToBottom) {
                requestAnimationFrame(function() {
                    window.scrollTo(0, document.body.scrollHeight);
                });
            }
        }

        function updateSessionWaitingState(sessionId) {
            const session = sessions.get(sessionId);
            if (!session) return;

            const status = sessionStatus.get(sessionId);
            const isWaiting = status && status.waiting_for_input;
            const hasUnread = session.sidebarItem.classList.contains('unread') ||
                              session.sidebarItem.classList.contains('waiting');

            // Update session item: waiting takes precedence over unread
            if (hasUnread && isWaiting) {
                session.sidebarItem.classList.remove('unread');
                session.sidebarItem.classList.add('waiting');
            } else if (hasUnread && !isWaiting) {
                session.sidebarItem.classList.remove('waiting');
                session.sidebarItem.classList.add('unread');
            }

            // Update project state
            updateProjectUnreadState(session.projectName);
        }

        function updateProjectUnreadState(projectName) {
            const project = projects.get(projectName);
            if (!project) return;

            // Check if any session in this project has unread/waiting messages
            let hasUnread = false;
            let hasWaiting = false;
            project.sessions.forEach(function(sessionId) {
                const session = sessions.get(sessionId);
                if (session) {
                    if (session.sidebarItem.classList.contains('waiting')) {
                        hasWaiting = true;
                    } else if (session.sidebarItem.classList.contains('unread')) {
                        hasUnread = true;
                    }
                }
            });

            // waiting takes precedence over unread for projects
            project.element.classList.remove('unread', 'waiting');
            if (hasWaiting) {
                project.element.classList.add('waiting');
            } else if (hasUnread) {
                project.element.classList.add('unread');
            }
        }

        function appendMessage(sessionId, html) {
            const session = sessions.get(sessionId);
            if (!session) return;

            const wasNearBottom = isNearBottom();
            const isActiveSession = sessionId === activeSessionId;

            const temp = document.createElement('div');
            temp.innerHTML = html;
            const msg = temp.firstElementChild;

            if (msg) {
                removePlaceholderIfMatches(sessionId, msg);

                session.container.appendChild(msg);
                processNewElement(msg);
                session.messageCount++;

                if (catchupComplete) {
                    session.lastActivity = Date.now();
                    session.lastUpdatedAt = Date.now() / 1000;

                    // Update project's last activity
                    const project = projects.get(session.projectName);
                    if (project) {
                        project.lastActivity = Math.max(project.lastActivity, session.lastActivity);
                    }

                    // Mark as unread/waiting if not the active session
                    if (!isActiveSession) {
                        const status = sessionStatus.get(sessionId);
                        if (status && status.waiting_for_input) {
                            session.sidebarItem.classList.add('waiting');
                        } else {
                            session.sidebarItem.classList.add('unread');
                        }
                        updateProjectUnreadState(session.projectName);
                    }

                    reorderSidebar();
                }

                while (session.container.children.length > MAX_MESSAGES + 1) {  // +1 for header
                    session.container.removeChild(session.container.children[1]);  // Skip header
                }

                // Handle auto-switch (only after initial catchup)
                if (catchupComplete && autoSwitch && !isActiveSession) {
                    if (autoSwitchDebounce) clearTimeout(autoSwitchDebounce);
                    autoSwitchDebounce = setTimeout(function() {
                        switchToSession(sessionId, true);
                    }, 100);
                }

                // Auto-scroll within session
                if (isActiveSession && (autoScroll || wasNearBottom)) {
                    msg.scrollIntoView({ behavior: 'smooth', block: 'end' });
                }
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function createPlaceholderMessage(sessionId, messageText) {
            const session = sessions.get(sessionId);
            if (!session) return null;

            const timestamp = new Date().toISOString();
            const msgId = 'placeholder-' + Date.now();

            const html = '<div class="message user placeholder-message" id="' + msgId + '">' +
                '<div class="message-header">' +
                '<span class="role-label">User</span>' +
                '<time datetime="' + timestamp + '">Sending...</time>' +
                '</div>' +
                '<div class="message-content">' +
                '<div class="user-content"><p>' + escapeHtml(messageText) + '</p></div>' +
                '</div>' +
                '</div>';

            const temp = document.createElement('div');
            temp.innerHTML = html;
            const element = temp.firstElementChild;

            session.container.appendChild(element);

            const placeholder = { sessionId: sessionId, messageText: messageText, element: element };
            pendingMessages.push(placeholder);

            element.scrollIntoView({ behavior: 'smooth', block: 'end' });

            return placeholder;
        }

        function removePlaceholderIfMatches(sessionId, messageElement) {
            const incomingContent = messageElement.querySelector('.user-content');
            if (!incomingContent) return;

            const incomingText = incomingContent.textContent.trim();

            for (let i = 0; i < pendingMessages.length; i++) {
                const pending = pendingMessages[i];
                if (pending.sessionId === sessionId && pending.messageText.trim() === incomingText) {
                    pending.element.remove();
                    pendingMessages.splice(i, 1);
                    return true;
                }
            }
            return false;
        }

        function connect() {
            updateStatus('reconnecting', 'Connecting...');
            catchupComplete = false;

            checkSendEnabled();
            checkForkEnabled();
            checkDefaultSendBackend();

            eventSource = new EventSource('/events');

            eventSource.addEventListener('sessions', function(e) {
                const data = JSON.parse(e.data);
                data.sessions.forEach(function(session) {
                    createSession(
                        session.id,
                        session.name,
                        session.projectName,
                        session.firstMessage,
                        session.startedAt,
                        session.lastUpdatedAt,
                        session.projectPath,
                        session.tokenUsage,
                        session.backend
                    );
                });
                reorderSidebar();
                const count = data.sessions.length;
                const countText = count >= 100 ? 'last 100 sessions' : count + ' session' + (count !== 1 ? 's' : '');
                updateStatus('', 'Connected (' + countText + ')');
            });

            eventSource.addEventListener('catchup_complete', function(e) {
                catchupComplete = true;
                if (activeSessionId) {
                    window.scrollTo(0, document.body.scrollHeight);
                }
            });

            eventSource.addEventListener('session_added', function(e) {
                const data = JSON.parse(e.data);

                let mergedPendingId = null;
                const MERGE_WINDOW_MS = 30000;
                sessions.forEach(function(session, sessionId) {
                    if (session.pending && session.starting &&
                        (Date.now() - session.startedAt) < MERGE_WINDOW_MS) {
                        mergedPendingId = sessionId;
                    }
                });

                if (mergedPendingId) {
                    const pendingSession = sessions.get(mergedPendingId);
                    const wasPendingActive = (activeSessionId === mergedPendingId);

                    removeSession(mergedPendingId);

                    const session = createSession(
                        data.id,
                        data.name,
                        data.projectName,
                        data.firstMessage,
                        data.startedAt,
                        data.lastUpdatedAt,
                        data.projectPath,
                        data.tokenUsage,
                        data.backend
                    );

                    if (wasPendingActive && session) {
                        switchToSession(data.id, true);
                    }
                } else {
                    const session = createSession(
                        data.id,
                        data.name,
                        data.projectName,
                        data.firstMessage,
                        data.startedAt,
                        data.lastUpdatedAt,
                        data.projectPath,
                        data.tokenUsage,
                        data.backend
                    );
                    if (autoSwitch && session) {
                        switchToSession(data.id, true);
                    }
                }
            });

            eventSource.addEventListener('session_removed', function(e) {
                const data = JSON.parse(e.data);
                removeSession(data.id);
            });

            eventSource.addEventListener('message', function(e) {
                const data = JSON.parse(e.data);
                if (data.type === 'html' && data.session_id) {
                    if (!sessions.has(data.session_id)) {
                        createSession(data.session_id, data.session_id.substring(0, 8), 'Unknown', null, null, null, null, null, null);
                    }
                    appendMessage(data.session_id, data.content);
                }
            });

            eventSource.addEventListener('ping', function(e) {
                // Keep-alive
            });

            eventSource.addEventListener('session_status', function(e) {
                const data = JSON.parse(e.data);
                sessionStatus.set(data.session_id, {
                    running: data.running,
                    queued_messages: data.queued_messages,
                    waiting_for_input: data.waiting_for_input
                });
                if (data.session_id === activeSessionId) {
                    updateInputBarUI();
                }
                // Update waiting state on sidebar
                updateSessionWaitingState(data.session_id);
            });

            eventSource.addEventListener('reinitialize', function(e) {
                console.warn('Server requested reinitialize:', JSON.parse(e.data));
                eventSource.close();
                setTimeout(connect, 1000);
            });

            eventSource.onopen = function() {
                updateStatus('', 'Connected');
            };

            eventSource.onerror = function(e) {
                if (eventSource.readyState === EventSource.CLOSED) {
                    updateStatus('disconnected', 'Disconnected');
                } else {
                    updateStatus('reconnecting', 'Reconnecting...');
                }
            };
        }

        connect();

        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'visible' && eventSource.readyState === EventSource.CLOSED) {
                connect();
            }
        });

        // Global click handler for copy buttons (event delegation)
        document.addEventListener('click', function(e) {
            const btn = e.target.closest('.copy-btn');
            if (!btn) return;

            e.stopPropagation();
            e.preventDefault();

            // Check if this is a file path copy button
            const fullpath = btn.closest('.file-tool-fullpath[data-copy-path]');
            if (fullpath) {
                const path = fullpath.dataset.copyPath;
                if (path) {
                    copyToClipboard(path, btn);
                }
                return;
            }

            // Otherwise it's a code block copy button
            const wrapper = btn.closest('.copy-wrapper');
            if (wrapper) {
                const pre = wrapper.querySelector('pre');
                if (pre) {
                    copyToClipboard(pre.textContent, btn);
                } else {
                    // Fallback: copy wrapper text content (excluding button)
                    const clone = wrapper.cloneNode(true);
                    const btnClone = clone.querySelector('.copy-btn');
                    if (btnClone) btnClone.remove();
                    copyToClipboard(clone.textContent.trim(), btn);
                }
            }
        });
    })();
    </script>
</body>
</html>
