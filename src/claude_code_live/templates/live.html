<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Code Live</title>
    <style>{{ css|safe }}</style>
</head>
<body>
    <div class="status-bar" id="status-bar">
        <div class="status-indicator">
            <span class="status-dot"></span>
            <span id="status-text">Connecting...</span>
        </div>
        <div id="session-info">last 10 sessions</div>
    </div>
    <div class="tab-bar" id="tab-bar">
        <div class="tabs" id="tabs"></div>
        <label class="auto-follow" id="auto-follow-label">
            <input type="checkbox" id="auto-follow" checked>
            Auto-follow
        </label>
    </div>
    <div class="container">
        <h1>Claude Code Live</h1>
        <div id="sessions"></div>
    </div>
    <script>
    (function() {
        const sessionsContainer = document.getElementById('sessions');
        const tabsContainer = document.getElementById('tabs');
        const statusBar = document.getElementById('status-bar');
        const statusText = document.getElementById('status-text');
        const sessionInfo = document.getElementById('session-info');
        const autoFollowCheckbox = document.getElementById('auto-follow');
        const autoFollowLabel = document.getElementById('auto-follow-label');

        let eventSource = null;
        const MAX_MESSAGES = 500;

        // State
        const sessions = new Map();  // session_id -> {name, container, messageCount, unread}
        let activeSessionId = null;
        let autoFollow = true;
        let autoFollowDebounce = null;
        let catchupComplete = false;  // Don't auto-follow during initial catchup

        // Update auto-follow UI
        function updateAutoFollowUI() {
            autoFollow = autoFollowCheckbox.checked;
            if (autoFollow) {
                autoFollowLabel.classList.add('active');
            } else {
                autoFollowLabel.classList.remove('active');
            }
        }
        autoFollowCheckbox.addEventListener('change', updateAutoFollowUI);
        updateAutoFollowUI();

        function updateStatus(status, text) {
            statusBar.className = 'status-bar ' + status;
            statusText.textContent = text;
        }

        function isNearBottom() {
            const threshold = 150;
            return (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - threshold);
        }

        function processNewElement(element) {
            // Localize timestamps
            element.querySelectorAll('time[data-timestamp]').forEach(function(el) {
                const timestamp = el.getAttribute('data-timestamp');
                const date = new Date(timestamp);
                const now = new Date();
                const isToday = date.toDateString() === now.toDateString();
                const timeStr = date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
                if (isToday) { el.textContent = timeStr; }
                else { el.textContent = date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) + ' ' + timeStr; }
            });

            // Syntax highlight JSON
            element.querySelectorAll('pre.json').forEach(function(el) {
                let text = el.textContent;
                text = text.replace(/"([^"]+)":/g, '<span style="color: #ce93d8">"$1"</span>:');
                text = text.replace(/: "([^"]*)"/g, ': <span style="color: #81d4fa">"$1"</span>');
                text = text.replace(/: (\d+)/g, ': <span style="color: #ffcc80">$1</span>');
                text = text.replace(/: (true|false|null)/g, ': <span style="color: #f48fb1">$1</span>');
                el.innerHTML = text;
            });

            // Setup truncatable content
            element.querySelectorAll('.truncatable').forEach(function(wrapper) {
                const content = wrapper.querySelector('.truncatable-content');
                const btn = wrapper.querySelector('.expand-btn');
                if (content && btn && content.scrollHeight > 250) {
                    wrapper.classList.add('truncated');
                    btn.addEventListener('click', function() {
                        if (wrapper.classList.contains('truncated')) {
                            wrapper.classList.remove('truncated');
                            wrapper.classList.add('expanded');
                            btn.textContent = 'Show less';
                        } else {
                            wrapper.classList.remove('expanded');
                            wrapper.classList.add('truncated');
                            btn.textContent = 'Show more';
                        }
                    });
                }
            });
        }

        function formatTimestamp(ts) {
            if (!ts) return 'Unknown';
            const date = typeof ts === 'number' ? new Date(ts * 1000) : new Date(ts);
            if (isNaN(date.getTime())) return 'Unknown';
            const now = new Date();
            const isToday = date.toDateString() === now.toDateString();
            const timeStr = date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' });
            if (isToday) {
                return 'Today ' + timeStr;
            }
            return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' }) + ' ' + timeStr;
        }

        function updateTabTooltip(session) {
            const started = formatTimestamp(session.startedAt);
            const updated = formatTimestamp(session.lastUpdatedAt);
            session.tab.title = 'Started: ' + started + '\nLast updated: ' + updated;
        }

        function createSession(sessionId, name, startedAt, lastUpdatedAt) {
            if (sessions.has(sessionId)) return sessions.get(sessionId);

            // Create container
            const container = document.createElement('div');
            container.className = 'session-container';
            container.dataset.session = sessionId;
            sessionsContainer.appendChild(container);

            // Create tab
            const tab = document.createElement('div');
            tab.className = 'tab';
            tab.dataset.session = sessionId;
            tab.innerHTML = `
                <span class="tab-name">${escapeHtml(name)}</span>
                <span class="close-btn" title="Close tab">&times;</span>
            `;
            tab.addEventListener('click', function(e) {
                if (e.target.classList.contains('close-btn')) {
                    removeSession(sessionId);
                } else {
                    switchToSession(sessionId);
                }
            });
            tabsContainer.appendChild(tab);

            const session = {
                id: sessionId,
                name: name,
                container: container,
                tab: tab,
                messageCount: 0,
                lastActivity: Date.now(),
                startedAt: startedAt || null,
                lastUpdatedAt: lastUpdatedAt || null
            };
            sessions.set(sessionId, session);
            updateTabTooltip(session);

            // If this is the first session, activate it
            if (sessions.size === 1) {
                switchToSession(sessionId);
            }

            return session;
        }

        function removeSession(sessionId) {
            const session = sessions.get(sessionId);
            if (!session) return;

            session.container.remove();
            session.tab.remove();
            sessions.delete(sessionId);

            // If we removed the active session, switch to another
            if (activeSessionId === sessionId) {
                const firstSession = sessions.keys().next().value;
                if (firstSession) {
                    switchToSession(firstSession);
                } else {
                    activeSessionId = null;
                }
            }
        }

        function reorderTabs() {
            // Sort sessions by lastActivity (most recent first)
            const sortedSessions = Array.from(sessions.values()).sort((a, b) => b.lastActivity - a.lastActivity);

            // FLIP animation: capture initial positions
            const positions = new Map();
            sortedSessions.forEach(session => {
                positions.set(session.id, session.tab.getBoundingClientRect().left);
            });

            // Reorder tabs in DOM
            sortedSessions.forEach(session => {
                tabsContainer.appendChild(session.tab);
            });

            // FLIP animation: animate from old position to new
            sortedSessions.forEach(session => {
                const oldLeft = positions.get(session.id);
                const newLeft = session.tab.getBoundingClientRect().left;
                const deltaX = oldLeft - newLeft;

                if (Math.abs(deltaX) > 1) {
                    session.tab.style.transform = `translateX(${deltaX}px)`;
                    session.tab.style.transition = 'none';

                    requestAnimationFrame(() => {
                        session.tab.style.transition = 'transform 0.3s ease';
                        session.tab.style.transform = '';
                    });
                }
            });
        }

        function switchToSession(sessionId, scrollToBottom = false) {
            const session = sessions.get(sessionId);
            if (!session) return;

            // Update containers
            sessions.forEach(function(s) {
                s.container.classList.remove('active');
                s.tab.classList.remove('active');
            });
            session.container.classList.add('active');
            session.tab.classList.add('active');
            activeSessionId = sessionId;

            // Scroll to bottom if requested (e.g., after auto-follow switch)
            if (scrollToBottom) {
                requestAnimationFrame(function() {
                    window.scrollTo(0, document.body.scrollHeight);
                });
            }
        }


        function appendMessage(sessionId, html) {
            const session = sessions.get(sessionId);
            if (!session) return;

            const wasNearBottom = isNearBottom();
            const isActiveSession = sessionId === activeSessionId;

            const temp = document.createElement('div');
            temp.innerHTML = html;
            const msg = temp.firstElementChild;

            if (msg) {
                session.container.appendChild(msg);
                processNewElement(msg);
                session.messageCount++;

                // Update last activity and reorder tabs (only after catchup)
                if (catchupComplete) {
                    session.lastActivity = Date.now();
                    session.lastUpdatedAt = Date.now() / 1000;  // Unix timestamp in seconds
                    updateTabTooltip(session);
                    reorderTabs();
                }

                // Prune old messages if over limit
                while (session.container.children.length > MAX_MESSAGES) {
                    session.container.removeChild(session.container.firstChild);
                }

                // Handle auto-follow (only after initial catchup is complete)
                if (catchupComplete && autoFollow && !isActiveSession) {
                    // Debounce auto-follow to avoid thrashing
                    if (autoFollowDebounce) clearTimeout(autoFollowDebounce);
                    autoFollowDebounce = setTimeout(function() {
                        switchToSession(sessionId, true);  // Scroll to bottom on auto-follow
                    }, 100);
                }

                // Auto-scroll: always scroll if auto-follow is on, or if near bottom
                if (isActiveSession && (autoFollow || wasNearBottom)) {
                    msg.scrollIntoView({ behavior: 'smooth', block: 'end' });
                }
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function connect() {
            updateStatus('reconnecting', 'Connecting...');
            catchupComplete = false;  // Reset for new connection

            eventSource = new EventSource('/events');

            eventSource.addEventListener('sessions', function(e) {
                const data = JSON.parse(e.data);
                data.sessions.forEach(function(session) {
                    createSession(session.id, session.name, session.startedAt, session.lastUpdatedAt);
                });
                updateStatus('', 'Connected');

                // Mark catchup as complete after a short delay
                // (allows initial message burst to finish without triggering auto-follow)
                setTimeout(function() {
                    catchupComplete = true;
                    // Scroll the active session to bottom after catchup
                    if (activeSessionId) {
                        window.scrollTo(0, document.body.scrollHeight);
                    }
                }, 500);
            });

            eventSource.addEventListener('session_added', function(e) {
                const data = JSON.parse(e.data);
                const session = createSession(data.id, data.name, data.startedAt, data.lastUpdatedAt);
                // Auto-switch to newly added sessions (they're likely the active one)
                if (autoFollow && session) {
                    switchToSession(data.id, true);  // Scroll to bottom on auto-follow
                }
            });

            eventSource.addEventListener('session_removed', function(e) {
                const data = JSON.parse(e.data);
                removeSession(data.id);
            });

            eventSource.addEventListener('message', function(e) {
                const data = JSON.parse(e.data);
                if (data.type === 'html' && data.session_id) {
                    // Ensure session exists
                    if (!sessions.has(data.session_id)) {
                        createSession(data.session_id, data.session_id.substring(0, 8), null, null);
                    }
                    appendMessage(data.session_id, data.content);
                }
            });

            eventSource.addEventListener('ping', function(e) {
                // Keep-alive, no action needed
            });

            eventSource.onopen = function() {
                updateStatus('', 'Connected');
            };

            eventSource.onerror = function(e) {
                if (eventSource.readyState === EventSource.CLOSED) {
                    updateStatus('disconnected', 'Disconnected');
                } else {
                    updateStatus('reconnecting', 'Reconnecting...');
                }
            };
        }

        // Start connection
        connect();

        // Handle visibility change to reconnect when tab becomes visible
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'visible' && eventSource.readyState === EventSource.CLOSED) {
                connect();
            }
        });
    })();
    </script>
</body>
</html>
